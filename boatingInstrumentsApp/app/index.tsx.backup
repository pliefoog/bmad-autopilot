import React, { useState, useEffect, useCallback } from 'react';
import { 
  View, 
  StyleSheet, 
  TouchableOpacity, 
  Text, 
  Dimensions,
  SafeAreaView,
  StatusBar,
} from 'react-native';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useNmeaStore } from '@/core/nmeaStore';
import { useThemeStore, useTheme } from '@/core/themeStore';
import { PaginatedDashboard } from '@/components/PaginatedDashboard';
import { AutopilotControlScreen } from '@/widgets/AutopilotControlScreen';
import { AlarmBanner } from '@/widgets/AlarmBanner';
import HeaderBar from '@/components/HeaderBar';
import ToastMessage, { ToastMessageData } from '@/components/ToastMessage';
import { ConnectionConfigDialog } from '@/widgets/ConnectionConfigDialog';
import { PlaybackFilePicker } from '@/widgets/PlaybackFilePicker';
import { getConnectionDefaults } from '@/services/connectionDefaults';
import { globalConnectionService } from '@/services/globalConnectionService';

// Constants for layout calculations
const { height: screenHeight } = Dimensions.get('window');
const HEADER_HEIGHT = 60;
const FOOTER_HEIGHT = 88; // Autopilot button (70) + bottom nav (18)
const ALARM_BANNER_HEIGHT = 50;

// Storage keys
const SELECTED_WIDGETS_KEY = 'selected-widgets';
const THEME_PREFERENCE_KEY = 'theme-preference';

export default function DashboardScreen() {
  const router = useRouter();
  const { connectionStatus, nmeaData, alarms, lastError } = useNmeaStore();
  const { mode: themeMode, setMode: setThemeMode } = useThemeStore();
  const theme = useTheme();

  // Connection settings
  const defaults = getConnectionDefaults();
  const [ip, setIp] = useState(defaults.ip);
  const [port, setPort] = useState(defaults.port.toString());
  const [protocol, setProtocol] = useState<'tcp' | 'udp' | 'websocket'>(defaults.protocol);

  // Widget and UI state
  const [selectedWidgets, setSelectedWidgets] = useState<string[]>([
    'depth', 'speed', 'wind', 'gps', 'compass', 'engine', 'battery', 'tanks', 'autopilot'
  ]);
  const [showAutopilotControl, setShowAutopilotControl] = useState(false);
  const [showConnectionDialog, setShowConnectionDialog] = useState(false);
  const [showPlaybackPicker, setShowPlaybackPicker] = useState(false);
  const [toastMessage, setToastMessage] = useState<ToastMessageData | null>(null);

  // Navigation session state
  const [navigationSession, setNavigationSession] = useState<{
    isRecording: boolean;
    startTime?: Date;
    sessionId?: string;
  }>({
    isRecording: false
  });

  // Load persisted data
  useEffect(() => {
    const loadPersistedData = async () => {
      try {
        // Load selected widgets
        const savedWidgets = await AsyncStorage.getItem(SELECTED_WIDGETS_KEY);
        if (savedWidgets) {
          setSelectedWidgets(JSON.parse(savedWidgets));
        }

        // Load theme preference
        const savedTheme = await AsyncStorage.getItem(THEME_PREFERENCE_KEY);
        if (savedTheme) {
          setThemeMode(savedTheme as 'day' | 'night' | 'red-night' | 'auto');
        }
      } catch (error) {
        console.error('Failed to load persisted data:', error);
      }
    };

    loadPersistedData();
  }, []); // Remove setThemeMode dependency to prevent loop

  // Save selected widgets when changed
  useEffect(() => {
    const saveWidgets = async () => {
      try {
        await AsyncStorage.setItem(SELECTED_WIDGETS_KEY, JSON.stringify(selectedWidgets));
      } catch (error) {
        console.error('Failed to save selected widgets:', error);
      }
    };

    saveWidgets();
  }, [selectedWidgets]);

  // Show toast for errors
  useEffect(() => {
    if (lastError) {
      setToastMessage({
        message: lastError,
        type: 'error',
        duration: 5000,
      });
    }
  }, [lastError]);

  // Helper functions for toast messages
  const showSuccessToast = useCallback((message: string) => {
    setToastMessage({
      message,
      type: 'success',
      duration: 3000,
    });
  }, []);

  const showErrorToast = useCallback((message: string) => {
    setToastMessage({
      message,
      type: 'error',
      duration: 5000,
    });
  }, []);

  // Auto-connection initialization
  useEffect(() => {
    console.log('[Dashboard] useEffect for connection initialization triggered');
    
    // Initialize global connection service with auto-connect
    const initializeConnection = async () => {
      console.log('[Dashboard] Starting auto-connection initialization...');
      
      try {
        await globalConnectionService.initialize();
        console.log('[Dashboard] Global connection service initialized successfully');
        
        // Update local state with current connection options
        const currentOptions = globalConnectionService.getCurrentOptions();
        if (currentOptions) {
          console.log('[Dashboard] Using connection options:', currentOptions);
          setIp(currentOptions.ip);
          setPort(currentOptions.port.toString());
          setProtocol(currentOptions.protocol);
        }

        // Show success toast to indicate auto-connection attempt
        showSuccessToast('Auto-connecting to NMEA Bridge...');
        
      } catch (error) {
        console.error('[Dashboard] Failed to initialize connection:', error);
        showErrorToast('Failed to auto-connect to NMEA Bridge');
      }
    };

    console.log('[Dashboard] Setting up initialization timer...');
    // Small delay to ensure component is fully mounted
    const timer = setTimeout(() => {
      console.log('[Dashboard] Timer fired, calling initializeConnection...');
      initializeConnection();
    }, 1000);

    return () => {
      console.log('[Dashboard] Cleaning up connection initialization timer');
      clearTimeout(timer);
    };
  }, [showSuccessToast, showErrorToast]);

  // Theme cycling
  const cycleTheme = useCallback(() => {
    const modes: ('day' | 'night' | 'red-night' | 'auto')[] = ['day', 'night', 'red-night', 'auto'];
    const currentIndex = modes.indexOf(themeMode);
    const nextMode = modes[(currentIndex + 1) % modes.length];
    setThemeMode(nextMode);
    
    // Persist theme preference
    AsyncStorage.setItem(THEME_PREFERENCE_KEY, nextMode);

    setToastMessage({
      message: `Theme: ${nextMode.toUpperCase()}`,
      type: 'success',
      duration: 2000,
    });
  }, [themeMode, setThemeMode]);

  // Widget management
  const handleWidgetSelectionChange = useCallback((newSelection: string[]) => {
    setSelectedWidgets(newSelection);
    // Navigate back to dashboard after widget selection
    router.back();
  }, [router]);

  const handleWidgetRemove = useCallback((widgetId: string) => {
    setSelectedWidgets(prev => prev.filter(id => id !== widgetId));
    setToastMessage({
      message: `${widgetId.toUpperCase()} widget removed`,
      type: 'success',
      duration: 3000,
    });
  }, []);

  // Connection handling
  const handleConnectionConnect = useCallback(async (config: { ip: string; port: number; protocol: 'tcp' | 'udp' | 'websocket' }) => {
    setIp(config.ip);
    setPort(config.port.toString());
    setProtocol(config.protocol);
    
    try {
      // Update connection using global service (handles graceful disconnect/reconnect)
      await globalConnectionService.updateConnection({
        ip: config.ip,
        port: config.port,
        protocol: config.protocol
      });
      
      setToastMessage({
        message: `Connected to ${config.ip}:${config.port} (${config.protocol.toUpperCase()})`,
        type: 'success',
        duration: 3000,
      });
    } catch (error) {
      console.error('Failed to connect:', error);
      setToastMessage({
        message: 'Failed to establish connection',
        type: 'error',
        duration: 3000,
      });
    }
  }, []);

  const handleConnectionDisconnect = useCallback(async () => {
    try {
      // Disconnect using global service
      await globalConnectionService.updateConnection({
        ip: '0.0.0.0',
        port: 0,
        protocol: 'tcp'
      }, false); // Don't save this dummy config
      
      setToastMessage({
        message: 'Disconnected from NMEA source',
        type: 'success',
        duration: 3000,
      });
    } catch (error) {
      console.error('Failed to disconnect:', error);
      setToastMessage({
        message: 'Failed to disconnect',
        type: 'error',
        duration: 3000,
      });
    }
  }, []);

  // Navigation session control
  const handleNavigationSessionToggle = useCallback(() => {
    if (navigationSession.isRecording) {
      // Stop recording
      setNavigationSession({ isRecording: false });
      setToastMessage({
        message: 'Navigation session stopped',
        type: 'success',
        duration: 3000,
      });
    } else {
      // Start recording
      const sessionId = `nav_${Date.now()}`;
      setNavigationSession({
        isRecording: true,
        startTime: new Date(),
        sessionId
      });
      setToastMessage({
        message: `Navigation session started: ${sessionId}`,
        type: 'success',
        duration: 3000,
      });
    }
  }, [navigationSession.isRecording]);

  // Theme helpers
  const getThemeIcon = () => {
    switch (themeMode) {
      case 'day': return 'â˜€ï¸';
      case 'night': return 'ðŸŒ™';
      case 'red-night': return 'ðŸ”´';
      case 'auto': return 'ðŸ”„';
      default: return 'ðŸ”„';
    }
  };

  const getThemeLabel = () => {
    switch (themeMode) {
      case 'day': return 'DAY';
      case 'night': return 'NIGHT';
      case 'red-night': return 'RED';
      case 'auto': return 'AUTO';
      default: return 'AUTO';
    }
  };

  return (
    <View style={[styles.container, { backgroundColor: theme.background }]}>
      <SafeAreaView style={{ backgroundColor: theme.surface }}>
        <StatusBar 
          backgroundColor={theme.surface} 
          barStyle={themeMode === 'night' || themeMode === 'red-night' ? 'light-content' : 'dark-content'} 
        />
      </SafeAreaView>
      
      {/* Header */}
      <HeaderBar
        onShowConnectionSettings={() => setShowConnectionDialog(true)}
        navigationSession={navigationSession}
        onToggleNavigationSession={handleNavigationSessionToggle}
        toastMessage={toastMessage}
      />

      {/* Alarm Banner */}
      {alarms && alarms.length > 0 && (
        <AlarmBanner alarms={alarms} />
      )}

      {/* Main Dashboard - Takes remaining space */}
      <View style={styles.dashboardArea}>
        <PaginatedDashboard
          selectedWidgets={selectedWidgets}
          onWidgetRemove={handleWidgetRemove}
          headerHeight={HEADER_HEIGHT + (alarms?.length > 0 ? ALARM_BANNER_HEIGHT : 0)}
          footerHeight={FOOTER_HEIGHT}
        />
      </View>

      {/* Footer - Fixed at bottom */}
      <View style={styles.footerArea}>
        {/* Autopilot Control Access */}
        {selectedWidgets.includes('autopilot') && (
          <TouchableOpacity
            style={[styles.autopilotAccess, { backgroundColor: theme.primary }]}
            onPress={() => setShowAutopilotControl(true)}
          >
            <Text style={[styles.autopilotAccessText, { color: theme.surface }]}>
              AUTOPILOT CONTROL
            </Text>
          </TouchableOpacity>
        )}

        {/* Bottom Navigation */}
        <View style={[styles.bottomNav, { backgroundColor: theme.surface }]}>
          <TouchableOpacity
            style={styles.navButton}
            onPress={() => router.push('/widget-selector')}
          >
            <Text style={[styles.navButtonIcon, { color: theme.primary }]}>+</Text>
            <Text style={[styles.navButtonText, { color: theme.textSecondary }]}>ADD</Text>
          </TouchableOpacity>

          <View style={[styles.navDivider, { backgroundColor: theme.border }]} />

          <TouchableOpacity 
            style={styles.navButton}
            onPress={cycleTheme}
          >
            <Text style={styles.navButtonIcon}>{getThemeIcon()}</Text>
            <Text style={[styles.navButtonText, { color: theme.textSecondary }]}>
              {getThemeLabel()}
            </Text>
          </TouchableOpacity>

          <View style={[styles.navDivider, { backgroundColor: theme.border }]} />

          <TouchableOpacity
            style={styles.navButton}
            onPress={() => router.push('/settings')}
          >
            <Text style={[styles.navButtonIcon, { color: theme.textSecondary }]}>âš™</Text>
            <Text style={[styles.navButtonText, { color: theme.textSecondary }]}>SET</Text>
          </TouchableOpacity>
        </View>
      </View>

      {/* Modals and Dialogs */}
      {showAutopilotControl && (
        <AutopilotControlScreen
          visible={showAutopilotControl}
          onClose={() => setShowAutopilotControl(false)}
        />
      )}

      {showConnectionDialog && (
        <ConnectionConfigDialog
          visible={showConnectionDialog}
          onClose={() => setShowConnectionDialog(false)}
          currentIp={ip}
          currentPort={parseInt(port)}
          currentProtocol={protocol}
          onConnect={handleConnectionConnect}
          onDisconnect={handleConnectionDisconnect}
        />
      )}

      {showPlaybackPicker && (
        <PlaybackFilePicker
          visible={showPlaybackPicker}
          onClose={() => setShowPlaybackPicker(false)}
        />
      )}

      {/* Toast Message */}
      {toastMessage && (
        <ToastMessage
          message={toastMessage.message}
          type={toastMessage.type}
          duration={toastMessage.duration}
          onDismiss={() => setToastMessage(null)}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  dashboardArea: {
    flex: 1,
  },
  footerArea: {
    // Fixed footer area
  },
  autopilotAccess: {
    height: 70,
    justifyContent: 'center',
    alignItems: 'center',
    marginHorizontal: 10,
    borderRadius: 8,
    marginBottom: 8,
  },
  autopilotAccessText: {
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  bottomNav: {
    flexDirection: 'row',
    paddingVertical: 12,
    borderTopWidth: 1,
  },
  navButton: {
    flex: 1,
    alignItems: 'center',
    paddingVertical: 8,
  },
  navButtonIcon: {
    fontSize: 20,
    marginBottom: 4,
  },
  navButtonText: {
    fontSize: 10,
    fontWeight: 'bold',
  },
  navDivider: {
    width: 1,
    marginHorizontal: 4,
  },
});