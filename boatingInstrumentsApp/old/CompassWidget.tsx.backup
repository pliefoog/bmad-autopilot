import React, { useMemo, useCallback, memo } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import Svg, { Circle, Line, Text as SvgText, G } from 'react-native-svg';
import { WidgetCard } from './WidgetCard';
import { PrimaryMetricCell } from '../components/PrimaryMetricCell';
import { useNmeaStore } from '../store/nmeaStore';
import { useTheme } from '../store/themeStore';

// Memoized CompassWidget with performance monitoring
export const CompassWidget: React.FC = memo(() => {
  // Optimized store selectors - only select what we need
  const heading = useNmeaStore(useCallback((state: any) => state.nmeaData.heading, []));
  const rateOfTurn = useNmeaStore(useCallback((state: any) => state.nmeaData.rateOfTurn, []));

  // Memoized display values to prevent recalculation on every render
  const displayValues = useMemo(() => {
    const displayHeading = heading !== undefined && heading !== null 
      ? `${Math.round(heading)}` 
      : '--';
      
    const displayROT = rateOfTurn !== undefined && rateOfTurn !== null
      ? `${rateOfTurn > 0 ? '+' : ''}${rateOfTurn.toFixed(1)}`
      : '--';
    
    const state: 'normal' | 'no-data' | 'alarm' | 'highlighted' | undefined = 
      heading === undefined || heading === null ? 'no-data' : 'normal';

    // Determine ROT state for color coding
    const getROTState = (): 'normal' | 'warning' | 'alarm' | undefined => {
      if (rateOfTurn === undefined || rateOfTurn === null) return undefined;
      const absROT = Math.abs(rateOfTurn);
      if (absROT > 10) return 'warning'; // Fast turn
      return 'normal';
    };

    const rotState = getROTState();

    return {
      displayHeading,
      displayROT,
      state,
      rotState,
    };
  }, [heading, rateOfTurn]);

  // Memoized compass rose props to prevent unnecessary re-renders
  const compassRoseProps = useMemo(() => ({
    heading: heading ?? 0,
    shouldRender: heading !== undefined && heading !== null,
  }), [heading]);

  // Story 4.4 AC6-10: Build comprehensive accessibility label for compass data
  const compassAccessibilityLabel = useMemo(() => {
    if (heading === undefined || heading === null) {
      return 'Compass: No heading data available';
    }
    
    const parts: string[] = ['Compass'];
    
    // Add heading with cardinal direction
    const getCardinalDirection = (hdg: number): string => {
      if (hdg < 22.5 || hdg >= 337.5) return 'North';
      if (hdg < 67.5) return 'North East';
      if (hdg < 112.5) return 'East';
      if (hdg < 157.5) return 'South East';
      if (hdg < 202.5) return 'South';
      if (hdg < 247.5) return 'South West';
      if (hdg < 292.5) return 'West';
      return 'North West';
    };
    
    parts.push(`Heading ${Math.round(heading)} degrees, ${getCardinalDirection(heading)}`);
    
    // Add rate of turn information
    if (rateOfTurn !== undefined && rateOfTurn !== null) {
      const absROT = Math.abs(rateOfTurn);
      if (absROT < 0.5) {
        parts.push('steady course');
      } else if (rateOfTurn > 0) {
        parts.push(`turning starboard, ${absROT.toFixed(1)} degrees per minute`);
        if (absROT > 10) parts.push('fast turn');
      } else {
        parts.push(`turning port, ${absROT.toFixed(1)} degrees per minute`);
        if (absROT > 10) parts.push('fast turn');
      }
    }
    
    return parts.join(', ');
  }, [heading, rateOfTurn]);

  const compassAccessibilityHint = useMemo(() => {
    if (heading === undefined || heading === null) {
      return 'Waiting for compass heading data';
    }
    if (rateOfTurn && Math.abs(rateOfTurn) > 10) {
      return 'Rapid turn in progress';
    }
    return 'Shows vessel heading and rate of turn';
  }, [heading, rateOfTurn]);

  return (
    <WidgetCard
      title="COMPASS"
      icon="navigate"
      state={displayValues.state}
      accessibilityLabel={compassAccessibilityLabel}
      accessibilityHint={compassAccessibilityHint}
      accessibilityRole="text"
      accessibilityValue={heading !== undefined && heading !== null ? {
        text: `${Math.round(heading)} degrees`,
        now: heading,
        min: 0,
        max: 360,
      } : undefined}
    >
      <View style={styles.metricGrid}>
        <PrimaryMetricCell
          mnemonic="HDG"
          value={displayValues.displayHeading}
          unit="°"
          state={heading !== undefined && heading !== null ? 'normal' : undefined}
          style={styles.metricCell}
        />
        <PrimaryMetricCell
          mnemonic="ROT"
          value={displayValues.displayROT}
          unit="°/min"
          state={displayValues.rotState}
          style={styles.metricCell}
        />
      </View>
      {compassRoseProps.shouldRender && (
        <View 
          style={styles.compassContainer}
          accessible={true}
          accessibilityLabel={`Compass heading ${Math.round(compassRoseProps.heading)} degrees`}
          accessibilityRole="image"
        >
          <CompassRose heading={compassRoseProps.heading} />
        </View>
      )}
    </WidgetCard>
  );
});

CompassWidget.displayName = 'CompassWidget';

interface CompassRoseProps {
  heading: number;
}

// Memoized CompassRose component with optimized SVG rendering
const CompassRose: React.FC<CompassRoseProps> = memo(({ heading }) => {
  const theme = useTheme();
  
  // Memoized constants to prevent recalculation
  const compassConfig = useMemo(() => ({
    size: 100,
    center: 50,
    radius: 40,
  }), []);

  const { size, center, radius } = compassConfig;
  
  // Memoized normalized heading calculation
  const normalizedHeading = useMemo(() => 
    ((heading % 360) + 360) % 360
  , [heading]);
  
  // Memoized cardinal directions with theme colors
  const cardinals = useMemo(() => [
    { label: 'N', angle: 0, color: theme.error }, // North in red (marine standard)
    { label: 'E', angle: 90, color: theme.text },
    { label: 'S', angle: 180, color: theme.text },
    { label: 'W', angle: 270, color: theme.text },
  ], [theme.error, theme.text]);
  
  // Memoized cardinal positions calculation
  const cardinalPositions = useMemo(() => {
    const getCardinalPosition = (angle: number) => {
      const adjustedAngle = (angle - normalizedHeading) * (Math.PI / 180);
      const x = center + radius * Math.sin(adjustedAngle);
      const y = center - radius * Math.cos(adjustedAngle);
      return {
        x: isNaN(x) ? center : x,
        y: isNaN(y) ? center : y,
      };
    };

    return cardinals.map(cardinal => ({
      ...cardinal,
      position: getCardinalPosition(cardinal.angle),
    }));
  }, [cardinals, normalizedHeading, center, radius]);
  
  // Memoized tick marks calculation - only recalculate when heading changes significantly
  const tickMarks = useMemo(() => {
    const ticks = Array.from({ length: 12 }, (_, i) => i * 30);
    
    return ticks.map((angle) => {
      const isCardinal = angle % 90 === 0;
      const tickLength = isCardinal ? 8 : 4;
      const adjustedAngle = (angle - normalizedHeading) * (Math.PI / 180);
      const x1_calc = center + (radius - tickLength) * Math.sin(adjustedAngle);
      const y1_calc = center - (radius - tickLength) * Math.cos(adjustedAngle);
      const x2_calc = center + radius * Math.sin(adjustedAngle);
      const y2_calc = center - radius * Math.cos(adjustedAngle);
      
      return {
        angle,
        isCardinal,
        x1: isNaN(x1_calc) ? center : x1_calc,
        y1: isNaN(y1_calc) ? center : y1_calc,
        x2: isNaN(x2_calc) ? center : x2_calc,
        y2: isNaN(y2_calc) ? center : y2_calc,
      };
    });
  }, [normalizedHeading, center, radius]);
  
  return (
    <Svg height={size} width={size}>
      <G>
        {/* Outer circle */}
        <Circle
          cx={center}
          cy={center}
          r={radius}
          stroke={theme.border}
          strokeWidth="2"
          fill="none"
        />
        
        {/* Tick marks */}
        {tickMarks.map((tick) => (
          <Line
            key={tick.angle}
            x1={tick.x1}
            y1={tick.y1}
            x2={tick.x2}
            y2={tick.y2}
            stroke={theme.border}
            strokeWidth={tick.isCardinal ? "2" : "1"}
          />
        ))}
        
        {/* Cardinal directions */}
        {cardinalPositions.map((cardinal) => (
          <SvgText
            key={cardinal.label}
            x={cardinal.position.x}
            y={cardinal.position.y + 5}
            fontSize="14"
            fontWeight="bold"
            fill={cardinal.color}
            textAnchor="middle"
          >
            {cardinal.label}
          </SvgText>
        ))}
        
        {/* Center dot */}
        <Circle
          cx={center}
          cy={center}
          r={3}
          fill={theme.primary}
        />
        
        {/* Heading needle pointing up */}
        <Line
          x1={center}
          y1={center}
          x2={center}
          y2={center - 25}
          stroke={theme.primary}
          strokeWidth="3"
          strokeLinecap="round"
        />
      </G>
    </Svg>
  );
});

CompassRose.displayName = 'CompassRose';

const styles = StyleSheet.create({
  metricGrid: {
    flexDirection: 'row',
    flex: 1,
  },
  metricCell: {
    flex: 1,
  },
  compassContainer: {
    marginTop: 12,
    alignItems: 'center',
    justifyContent: 'center',
  },
});
