import { create } from 'zustand';
import type { 
  SensorsData, 
  SensorType, 
  SensorData,
  TankSensorData,
  EngineSensorData,
  BatterySensorData,
  WindSensorData,
  SpeedSensorData,
  GpsSensorData,
  TemperatureSensorData,
  DepthSensorData,
  CompassSensorData,
  AutopilotSensorData
} from '../types/SensorData';

// MEMORY LEAK FIX: Throttle map for sensor updates
const sensorUpdateThrottles = new Map<string, number>();
const SENSOR_UPDATE_THROTTLE_MS = 100; // Max 10 updates/second per sensor

// MEMORY LEAK FIX: Throttle alarm evaluation (expensive operation)
let lastAlarmEvaluation = 0;
const ALARM_EVALUATION_THROTTLE_MS = 1000; // Max 1 alarm check per second

export type ConnectionStatus = 'disconnected' | 'connecting' | 'connected' | 'no-data';
export type AlarmLevel = 'info' | 'warning' | 'critical';

export interface Alarm {
  id: string;
  message: string;
  level: AlarmLevel;
  timestamp: number;
}

/**
 * Historical data point for sensor readings
 */
export interface HistoryDataPoint {
  value: number;
  timestamp: number;
}

/**
 * History tracking for a single sensor type
 */
export interface SensorHistory {
  values: HistoryDataPoint[];
  sessionMin: number | null;
  sessionMax: number | null;
  currentSource?: string; // Track which source is providing data (e.g., 'DPT', 'DBT', 'DBK')
  maxEntries: number; // Maximum number of entries to keep
  timeWindow: number; // Time window in milliseconds (dynamically adjusted based on subscriptions)
}

/**
 * Subscription to sensor history
 */
export interface HistorySubscription {
  widgetId: string;
  sensorType: SensorType;
  timeWindowMs: number;
}

/**
 * Collection of sensor histories
 * For multi-instance sensors (temperature, engine, battery), use instanceId as key
 * For single-instance sensors (depth, wind, speed), use sensor type as key
 */
export interface SensorHistories {
  depth: SensorHistory;
  wind: SensorHistory;
  speed: SensorHistory;
  engine: Record<string, SensorHistory>; // Per-instance: 'engine-0', 'engine-1'
  battery: Record<string, SensorHistory>; // Per-instance: 'battery-0', 'battery-1'
  temperature: Record<string, SensorHistory>; // Per-instance: 'temp-0', 'temp-1', etc.
}

/**
 * Clean NMEA Data Structure v2.0
 * 
 * Widget-centric design with protocol-agnostic sensor data.
 * Each widget type has a single entry point in sensors.
 */
export interface NmeaData {
  // Clean widget-centric sensor data
  sensors: SensorsData;
  
  // System-level metadata
  timestamp: number;
  messageCount: number;
}

/**
 * Clean NMEA Store Interface v2.0
 * 
 * Widget-centric design with simplified sensor data management.
 */
interface NmeaStore {
  // Core state
  connectionStatus: ConnectionStatus;
  nmeaData: NmeaData;
  alarms: Alarm[];
  lastError?: string;
  debugMode: boolean;
  
  // Historical data
  sensorHistories: SensorHistories;
  historySubscriptions: HistorySubscription[];
  
  // Connection management
  setConnectionStatus: (status: ConnectionStatus) => void;
  setLastError: (err?: string) => void;
  setDebugMode: (enabled: boolean) => void;
  
  // Sensor data management
  updateSensorData: <T extends SensorType>(sensorType: T, instance: number, data: Partial<SensorData>) => void;
  getSensorData: <T extends SensorType>(sensorType: T, instance: number) => SensorData | undefined;
  getSensorInstances: <T extends SensorType>(sensorType: T) => Array<{ instance: number; data: SensorData }>;
  
  // History management - CLEANED UP: addHistoryReading removed, handled automatically
  getHistory: (sensorType: keyof SensorHistories) => SensorHistory;
  subscribeToHistory: (widgetId: string, sensorType: SensorType, timeWindowMs: number) => void;
  unsubscribeFromHistory: (widgetId: string, sensorType: SensorType) => void;
  pruneHistory: (sensorType: keyof SensorHistories) => void;
  clearSensorHistory: (sensorType: keyof SensorHistories) => void;
  
  // System methods
  updateAlarms: (alarms: Alarm[]) => void;
  reset: () => void;
  
  // Legacy methods for backward compatibility during migration
  getTankData: (instance: number) => TankSensorData | undefined;
  getEngineData: (instance: number) => EngineSensorData | undefined;
  getBatteryData: (instance: number) => BatterySensorData | undefined;
  getTemperatureData: (instance: number) => TemperatureSensorData | undefined;
}

// Utility: Evaluate sensor data and return triggered alarms
function evaluateAlarms(nmeaData: NmeaData): Alarm[] {
  const alarms: Alarm[] = [];
  const now = Date.now();
  
  // Check depth sensors for shallow water
  Object.values(nmeaData.sensors.depth || {}).forEach((depthSensor) => {
    if (depthSensor.depth !== undefined && depthSensor.depth < 2) {
      alarms.push({
        id: `shallow-depth-${depthSensor.name}`,
        message: `Shallow depth: ${depthSensor.depth}m (${depthSensor.name})`,
        level: 'critical',
        timestamp: now,
      });
    }
  });
  
  // Check battery sensors for low voltage
  Object.values(nmeaData.sensors.battery || {}).forEach((batterySensor) => {
    if (batterySensor.voltage !== undefined && batterySensor.voltage < 11.5) {
      alarms.push({
        id: `low-battery-${batterySensor.name}`,
        message: `Low battery: ${batterySensor.voltage}V (${batterySensor.name})`,
        level: 'warning',
        timestamp: now,
      });
    }
  });
  
  // Check engine sensors for overheating
  Object.values(nmeaData.sensors.engine || {}).forEach((engineSensor) => {
    if (engineSensor.coolantTemp !== undefined && engineSensor.coolantTemp > 95) {
      alarms.push({
        id: `engine-overheat-${engineSensor.name}`,
        message: `Engine overheat: ${engineSensor.coolantTemp}Â°C (${engineSensor.name})`,
        level: 'critical',
        timestamp: now,
      });
    }
  });
  
  return alarms;
}

// CLEAN IMPLEMENTATION: Update history at data ingestion, not in widgets
function updateHistoryForSensor(state: NmeaStore, sensorType: SensorType, instance: number, sensorData: any): NmeaStore {
  // Only track history for sensors with subscriptions
  const hasSubscription = state.historySubscriptions.some(sub => sub.sensorType === sensorType);
  if (!hasSubscription) {
    return state;
  }

  // Extract trackable value based on sensor type
  let value: number | null = null;
  let source: string | undefined;

  switch (sensorType) {
    case 'depth':
      value = sensorData.depth;
      source = sensorData.referencePoint || 'DPT';
      break;
    case 'temperature':
      value = sensorData.value;
      source = `temp-${instance}`;
      break;
    case 'wind':
      value = sensorData.speed;
      break;
    case 'speed':
      value = sensorData.sog || sensorData.stw;
      break;
    case 'engine':
      value = sensorData.rpm;
      source = `engine-${instance}`;
      break;
    case 'battery':
      value = sensorData.voltage;
      source = `battery-${instance}`;
      break;
    default:
      return state;
  }

  if (value === null || value === undefined || isNaN(value)) {
    return state;
  }

  const timestamp = sensorData.timestamp || Date.now();
  const isMultiInstance = ['temperature', 'engine', 'battery'].includes(sensorType);

  let history: SensorHistory;
  if (isMultiInstance) {
    const instanceKey = source || 'default';
    const instanceMap = state.sensorHistories[sensorType as keyof SensorHistories] as Record<string, SensorHistory>;
    history = instanceMap[instanceKey] || createInitialHistory();
  } else {
    history = state.sensorHistories[sensorType as keyof SensorHistories] as SensorHistory;
  }

  // Check for duplicate
  const lastEntry = history.values[history.values.length - 1];
  if (lastEntry && Math.abs(lastEntry.value - value) < 0.01 && (timestamp - lastEntry.timestamp) < 100) {
    return state;
  }

  // Prune and add
  const cutoffTime = timestamp - history.timeWindow;
  const newValues = [...history.values, { value, timestamp }]
    .filter(entry => entry.timestamp > cutoffTime)
    .slice(-history.maxEntries);

  const sessionMin = history.sessionMin !== null ? Math.min(history.sessionMin, value) : value;
  const sessionMax = history.sessionMax !== null ? Math.max(history.sessionMax, value) : value;

  const updatedHistory = {
    ...history,
    values: newValues,
    sessionMin,
    sessionMax,
    currentSource: source || history.currentSource,
  };

  if (isMultiInstance) {
    const instanceKey = source || 'default';
    return {
      ...state,
      sensorHistories: {
        ...state.sensorHistories,
        [sensorType]: {
          ...(state.sensorHistories[sensorType as keyof SensorHistories] as Record<string, SensorHistory>),
          [instanceKey]: updatedHistory,
        },
      },
    };
  } else {
    return {
      ...state,
      sensorHistories: {
        ...state.sensorHistories,
        [sensorType]: updatedHistory,
      },
    };
  }
}

/**
 * Create initial sensor history structure
 */
function createInitialHistory(): SensorHistory {
  return {
    values: [],
    sessionMin: null,
    sessionMax: null,
    currentSource: undefined,
    maxEntries: 1000, // Will be adjusted based on platform (500 for mobile)
    timeWindow: 60 * 60 * 1000, // 1 hour default, adjusted dynamically
  };
}

/**
 * Calculate optimal time window based on active subscriptions
 */
function calculateTimeWindow(subscriptions: HistorySubscription[], sensorType: SensorType): number {
  const relevantSubs = subscriptions.filter(sub => sub.sensorType === sensorType);
  if (relevantSubs.length === 0) return 0; // No subscriptions
  
  const maxWindow = Math.max(...relevantSubs.map(sub => sub.timeWindowMs));
  return Math.min(maxWindow, 60 * 60 * 1000); // Cap at 1 hour
}

export const useNmeaStore = create<NmeaStore>((set, get) => ({
  // Initial state
  connectionStatus: 'disconnected',
  nmeaData: {
    sensors: {
      tank: {},
      engine: {},
      battery: {},
      wind: {},
      speed: {},
      gps: {},
      temperature: {},
      depth: {},
      compass: {},
      autopilot: {}
    },
    timestamp: Date.now(),
    messageCount: 0
  },
  alarms: [],
  lastError: undefined,
  debugMode: false,

  // Initial sensor histories
  sensorHistories: {
    depth: createInitialHistory(),
    wind: createInitialHistory(),
    speed: createInitialHistory(),
    engine: {},
    battery: {},
    temperature: {},
  },
  historySubscriptions: [],

  // Connection management
  setConnectionStatus: (status: ConnectionStatus) => set({ connectionStatus: status }),
  setLastError: (err?: string) => set({ lastError: err }),
  setDebugMode: (enabled: boolean) => set({ debugMode: enabled }),

  // Core sensor data management
  updateSensorData: <T extends SensorType>(sensorType: T, instance: number, data: Partial<SensorData>) => 
    set((state) => {
      // MEMORY LEAK FIX: Throttle updates to prevent 80+ updates/second
      const throttleKey = `${sensorType}-${instance}`;
      const now = Date.now();
      const lastUpdate = sensorUpdateThrottles.get(throttleKey);
      
      if (lastUpdate && (now - lastUpdate) < SENSOR_UPDATE_THROTTLE_MS) {
        // Skip this update - too frequent
        return state;
      }
      
      sensorUpdateThrottles.set(throttleKey, now);
      
      const currentSensorData = state.nmeaData.sensors[sensorType][instance] || {};
      const updatedSensorData = {
        ...currentSensorData,
        ...data,
        timestamp: Date.now()
      };

      // CLEAN IMPLEMENTATION: Update history directly here at data ingestion, not in widgets
      const newState = updateHistoryForSensor(state, sensorType, instance, updatedSensorData);

      const newNmeaData = {
        ...newState.nmeaData,
        sensors: {
          ...newState.nmeaData.sensors,
          [sensorType]: {
            ...newState.nmeaData.sensors[sensorType],
            [instance]: updatedSensorData
          }
        },
        timestamp: Date.now(),
        messageCount: newState.nmeaData.messageCount + 1
      };

      // MEMORY LEAK FIX: Throttle alarm evaluation to prevent 80+ evaluations per second
      let alarms = state.alarms; // Keep existing alarms by default
      
      if ((now - lastAlarmEvaluation) > ALARM_EVALUATION_THROTTLE_MS) {
        alarms = evaluateAlarms(newNmeaData);
        lastAlarmEvaluation = now;
      }

      return {
        nmeaData: newNmeaData,
        alarms
      };
    }),

  getSensorData: <T extends SensorType>(sensorType: T, instance: number) => {
    const state = get();
    return state.nmeaData.sensors[sensorType]?.[instance];
  },

  getSensorInstances: <T extends SensorType>(sensorType: T) => {
    const state = get();
    const sensorGroup = state.nmeaData.sensors[sensorType];
    return Object.entries(sensorGroup).map(([instance, data]) => ({
      instance: parseInt(instance, 10),
      data: data as SensorData
    }));
  },

  updateAlarms: (alarms: Alarm[]) => set({ alarms }),

  // REMOVED: addHistoryReading - now handled automatically in updateSensorData

  getHistory: (sensorType: keyof SensorHistories) => {
    const state = get();
    return state.sensorHistories[sensorType];
  },

  subscribeToHistory: (widgetId: string, sensorType: SensorType, timeWindowMs: number) => 
    set((state) => {
      // Check if subscription already exists
      const exists = state.historySubscriptions.some(
        sub => sub.widgetId === widgetId && sub.sensorType === sensorType
      );
      
      if (exists) return state; // Already subscribed
      
      const newSubscriptions = [
        ...state.historySubscriptions,
        { widgetId, sensorType, timeWindowMs },
      ];
      
      // Calculate new time window for this sensor type
      const newTimeWindow = calculateTimeWindow(newSubscriptions, sensorType);
      
      // Update history configuration if the sensor type exists in histories
      const sensorHistories = { ...state.sensorHistories };
      const historyKey = sensorType as keyof SensorHistories;
      if (sensorHistories[historyKey]) {
        sensorHistories[historyKey] = {
          ...sensorHistories[historyKey],
          timeWindow: newTimeWindow,
        };
      }
      
      return {
        historySubscriptions: newSubscriptions,
        sensorHistories,
      };
    }),

  unsubscribeFromHistory: (widgetId: string, sensorType: SensorType) => 
    set((state) => {
      const newSubscriptions = state.historySubscriptions.filter(
        sub => !(sub.widgetId === widgetId && sub.sensorType === sensorType)
      );
      
      // Calculate new time window for this sensor type
      const newTimeWindow = calculateTimeWindow(newSubscriptions, sensorType);
      
      // Update history configuration
      const sensorHistories = { ...state.sensorHistories };
      const historyKey = sensorType as keyof SensorHistories;
      if (sensorHistories[historyKey]) {
        sensorHistories[historyKey] = {
          ...sensorHistories[historyKey],
          timeWindow: newTimeWindow,
        };
        
        // If no more subscriptions, schedule cleanup after grace period (5 minutes)
        // MEMORY LEAK FIX: Avoid holding store reference in closure
        if (newTimeWindow === 0) {
          const timeoutId = setTimeout(() => {
            try {
              const currentState = get();
              const stillNoSubscriptions = calculateTimeWindow(currentState.historySubscriptions, sensorType) === 0;
              if (stillNoSubscriptions) {
                if (currentState.debugMode) {
                  console.log(`[Store History] Grace period expired, clearing ${historyKey} history`);
                }
                get().clearSensorHistory(historyKey);
              }
            } catch (error) {
              console.error('[Store History] Cleanup error:', error);
            }
          }, 5 * 60 * 1000);
          
          // Store timeout ID for potential cleanup (future enhancement)
          if (typeof window !== 'undefined') {
            (window as any).__storeHistoryTimeouts = (window as any).__storeHistoryTimeouts || [];
            (window as any).__storeHistoryTimeouts.push(timeoutId);
          }
        }
      }
      
      return {
        historySubscriptions: newSubscriptions,
        sensorHistories,
      };
    }),

  pruneHistory: (sensorType: keyof SensorHistories) => 
    set((state) => {
      const history = state.sensorHistories[sensorType];
      const now = Date.now();
      const cutoffTime = now - history.timeWindow;
      
      const prunedValues = history.values
        .filter(entry => entry.timestamp > cutoffTime)
        .slice(-history.maxEntries);
      
      return {
        sensorHistories: {
          ...state.sensorHistories,
          [sensorType]: {
            ...history,
            values: prunedValues,
          },
        },
      };
    }),

  clearSensorHistory: (sensorType: keyof SensorHistories) => 
    set((state) => ({
      sensorHistories: {
        ...state.sensorHistories,
        [sensorType]: createInitialHistory(),
      },
    })),

  updateAlarms: (alarms: Alarm[]) => set({ alarms }),

  reset: () => set({
    connectionStatus: 'disconnected',
    nmeaData: {
      sensors: {
        tank: {},
        engine: {},
        battery: {},
        wind: {},
        speed: {},
        gps: {},
        temperature: {},
        depth: {},
        compass: {},
        autopilot: {}
      },
      timestamp: Date.now(),
      messageCount: 0
    },
    alarms: [],
    lastError: undefined,
    debugMode: false,
    sensorHistories: {
      depth: createInitialHistory(),
      wind: createInitialHistory(),
      speed: createInitialHistory(),
      engine: {},
      battery: {},
      temperature: {},
    },
    historySubscriptions: [],
  }),

  // Legacy compatibility methods (will be removed after migration)
  getTankData: (instance: number) => {
    const state = get();
    return state.nmeaData.sensors.tank[instance] as TankSensorData | undefined;
  },

  getEngineData: (instance: number) => {
    const state = get();
    return state.nmeaData.sensors.engine[instance] as EngineSensorData | undefined;
  },

  getBatteryData: (instance: number) => {
    const state = get();
    return state.nmeaData.sensors.battery[instance] as BatterySensorData | undefined;
  },

  getTemperatureData: (instance: number) => {
    const state = get();
    return state.nmeaData.sensors.temperature[instance] as TemperatureSensorData | undefined;
  },
}));
