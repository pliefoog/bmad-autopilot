/**
 * Alarm Configuration Dialog
 * Modal with internal navigation for alarm list and detail views
 * Matches UnitsConfigDialog pattern for consistency
 */

import React, { useState, useEffect, useMemo } from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  ScrollView,
  Pressable,
  TextInput,
  Alert,
  ActivityIndicator,
  TouchableOpacity,
  Platform,
} from 'react-native';
import Switch from '../atoms/Switch';
import { useTheme, ThemeColors } from '../../store/themeStore';
import { UniversalIcon } from '../atoms/UniversalIcon';
import { CriticalAlarmConfiguration } from '../../services/alarms/CriticalAlarmConfiguration';
import { CriticalAlarmType, CriticalAlarmConfig, AlarmEscalationLevel } from '../../services/alarms/types';
import { MarineAudioAlertManager } from '../../services/alarms/MarineAudioAlertManager';
import { useDataPresentation } from '../../presentation/useDataPresentation';
import { DataCategory } from '../../presentation/categories';
import { logger } from '../../utils/logger';

// Use shared singleton instances
const alarmConfig = CriticalAlarmConfiguration.getInstance();
const audioManager = MarineAudioAlertManager.getInstance();

// Critical alarms that cannot be disabled
const CRITICAL_ALARMS_NO_DISABLE = [CriticalAlarmType.SHALLOW_WATER];

// Helper function to check if alarm can be disabled
const canDisableAlarm = (type: CriticalAlarmType) => 
  !CRITICAL_ALARMS_NO_DISABLE.includes(type);

// Map alarm types to presentation categories for unit conversion
const ALARM_TYPE_TO_CATEGORY: Partial<Record<CriticalAlarmType, DataCategory>> = {
  [CriticalAlarmType.SHALLOW_WATER]: 'depth',
  [CriticalAlarmType.DEEP_WATER]: 'depth',
  [CriticalAlarmType.HIGH_SPEED]: 'speed',
  [CriticalAlarmType.ENGINE_OVERHEAT]: 'temperature',
  [CriticalAlarmType.ENGINE_LOW_TEMP]: 'temperature',
  [CriticalAlarmType.LOW_BATTERY]: 'voltage',
  [CriticalAlarmType.HIGH_BATTERY]: 'voltage',
  [CriticalAlarmType.LOW_ALTERNATOR]: 'voltage',
  [CriticalAlarmType.HIGH_CURRENT]: 'current',
};

// Smart step size calculation based on unit and value range
const getSmartStep = (unit: string, rangeSize: number): number => {
  // RPM needs large steps
  if (unit === 'rpm') return 50;
  
  // Percentages use 1% steps
  if (unit === '%') return 1;
  
  // Pressure (PSI) uses 1 PSI steps
  if (unit === 'PSI') return 1;
  
  // Current (Amps) uses 5A steps
  if (unit === 'A' || unit.toLowerCase().includes('amp')) return 5;
  
  // Speed (knots) uses 1 knot steps
  if (unit === 'kn' || unit === 'kts') return 1;
  
  // Large ranges (>100) use integer steps
  if (rangeSize > 100) return 1;
  
  // Temperature uses 1 degree steps
  if (unit === '°C' || unit === '°F') return 1;
  
  // Small ranges use 0.1 steps
  return 0.1;
};

// Local Switch component to bypass any rendering issues
const LocalSwitch: React.FC<{
  value: boolean;
  onValueChange: (value: boolean) => void;
  trackColor?: { false?: string; true?: string };
  disabled?: boolean;
}> = ({ value, onValueChange, trackColor, disabled }) => {
  const theme = useTheme();
  
  const finalTrackColor = value 
    ? (trackColor?.true || theme.interactive)
    : (trackColor?.false || theme.border);
  
  const finalThumbColor = theme.surface;
  
  const handlePress = () => {
    if (!disabled) {
      console.log('[LocalSwitch] Current value:', value, '-> New value:', !value);
      onValueChange(!value);
    } else {
      console.log('[LocalSwitch] Press ignored - switch is disabled');
    }
  };
  
  return (
    <Pressable
      onPress={handlePress}
      disabled={disabled}
      hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
      style={({ pressed }) => ({
        width: 36,
        height: 20,
        borderRadius: 10,
        padding: 2,
        backgroundColor: finalTrackColor,
        opacity: disabled ? 0.5 : pressed ? 0.8 : 1,
      })}
    >
      <View
        style={{
          width: 16,
          height: 16,
          borderRadius: 8,
          backgroundColor: finalThumbColor,
          transform: [{ translateX: value ? 14 : 0 }],
        }}
        pointerEvents="none"
      />
    </Pressable>
  );
};

// Alarm list configuration - ALL 19 alarm types organized by category
const ALARM_CATEGORIES = [
  {
    title: 'Navigation',
    alarms: [
      {
        type: CriticalAlarmType.SHALLOW_WATER,
        label: 'Shallow Water',
        iconName: 'arrow-down-outline',
        unit: 'm',
      },
      {
        type: CriticalAlarmType.DEEP_WATER,
        label: 'Deep Water',
        iconName: 'arrow-up-outline',
        unit: 'm',
      },
      {
        type: CriticalAlarmType.HIGH_SPEED,
        label: 'High Speed',
        iconName: 'speedometer-outline',
        unit: 'kn',
      },
    ],
  },
  {
    title: 'Engine',
    alarms: [
      {
        type: CriticalAlarmType.ENGINE_OVERHEAT,
        label: 'Engine Overheat',
        iconName: 'thermometer-outline',
        unit: '°C',
      },
      {
        type: CriticalAlarmType.ENGINE_LOW_TEMP,
        label: 'Engine Low Temp',
        iconName: 'thermometer-outline',
        unit: '°C',
      },
      {
        type: CriticalAlarmType.ENGINE_HIGH_RPM,
        label: 'Engine High RPM',
        iconName: 'speedometer-outline',
        unit: 'rpm',
      },
      {
        type: CriticalAlarmType.ENGINE_LOW_OIL_PRESSURE,
        label: 'Low Oil Pressure',
        iconName: 'water-outline',
        unit: 'PSI',
      },
    ],
  },
  {
    title: 'Electrical',
    alarms: [
      {
        type: CriticalAlarmType.LOW_BATTERY,
        label: 'Low Battery',
        iconName: 'battery-dead-outline',
        unit: 'V',
      },
      {
        type: CriticalAlarmType.HIGH_BATTERY,
        label: 'High Battery',
        iconName: 'battery-charging-outline',
        unit: 'V',
      },
      {
        type: CriticalAlarmType.LOW_ALTERNATOR,
        label: 'Low Alternator',
        iconName: 'flash-outline',
        unit: 'V',
      },
      {
        type: CriticalAlarmType.HIGH_CURRENT,
        label: 'High Current',
        iconName: 'flash-outline',
        unit: 'A',
      },
    ],
  },
  {
    title: 'Wind',
    alarms: [
      {
        type: CriticalAlarmType.HIGH_WIND,
        label: 'High Wind',
        iconName: 'cloudy-outline',
        unit: 'kn',
      },
      {
        type: CriticalAlarmType.WIND_GUST,
        label: 'Wind Gust',
        iconName: 'cloudy-outline',
        unit: 'kn',
      },
    ],
  },
  {
    title: 'System',
    alarms: [
      {
        type: CriticalAlarmType.AUTOPILOT_FAILURE,
        label: 'Autopilot Failure',
        iconName: 'swap-horizontal-outline',
        unit: '',
      },
      {
        type: CriticalAlarmType.GPS_LOSS,
        label: 'GPS Signal Loss',
        iconName: 'navigate-outline',
        unit: 's',
      },
    ],
  },
  {
    title: 'Tanks',
    alarms: [
      {
        type: CriticalAlarmType.LOW_FUEL,
        label: 'Low Fuel',
        iconName: 'beaker-outline',
        unit: '%',
      },
      {
        type: CriticalAlarmType.LOW_WATER,
        label: 'Low Fresh Water',
        iconName: 'water-outline',
        unit: '%',
      },
      {
        type: CriticalAlarmType.HIGH_WASTE_WATER,
        label: 'High Waste Water',
        iconName: 'warning-outline',
        unit: '%',
      },
    ],
  },
];

// Flatten for backward compatibility
const ALARM_LIST = ALARM_CATEGORIES.flatMap(cat => cat.alarms);

// Alarm metadata for detail view - comprehensive configuration
interface AlarmMetadata {
  label: string;
  description: string;
  iconName: string;
  baseUnit: string; // Reference unit (meters, celsius, etc.)
  hasMin: boolean;
  hasMax: boolean;
  hasWarning: boolean;
  minLabel?: string;
  maxLabel?: string;
  warningLabel?: string;
  // Ranges always in reference units (will be converted for display)
  minRange: { min: number; max: number; default: number };
  maxRange: { min: number; max: number; default: number };
  warningRange: { min: number; max: number; default: number };
  defaultPattern: 'rapid_pulse' | 'warble' | 'intermittent' | 'triple_blast' | 'morse_u' | 'continuous_descending';
  patternDescription: string;
  allowDecimals?: boolean; // False for RPM, integers only
}

const ALARM_METADATA: Record<string, AlarmMetadata> = {
  // === NAVIGATION ===
  [CriticalAlarmType.SHALLOW_WATER]: {
    label: 'Shallow Water',
    description: 'Alert when depth falls below configured threshold. Critical for preventing grounding in shallow waters.',
    iconName: 'arrow-down-outline',
    baseUnit: 'm',
    hasMin: true,
    hasMax: false,
    hasWarning: true,
    minLabel: 'Critical Minimum Depth',
    warningLabel: 'Warning Depth',
    minRange: { min: 0.5, max: 10.0, default: 2.0 },
    maxRange: { min: 0, max: 0, default: 9999 },
    warningRange: { min: 1.0, max: 15.0, default: 2.5 },
    defaultPattern: 'rapid_pulse',
    patternDescription: 'Rapid pulse - ISO Priority 1 immediate danger',
    allowDecimals: true,
  },
  [CriticalAlarmType.DEEP_WATER]: {
    label: 'Deep Water',
    description: 'Alert when depth exceeds configured threshold. Useful for inland/coastal navigation.',
    iconName: 'arrow-up-outline',
    baseUnit: 'm',
    hasMin: false,
    hasMax: true,
    hasWarning: true,
    maxLabel: 'Maximum Depth',
    warningLabel: 'Warning Depth',
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 20.0, max: 100.0, default: 50.0 },
    warningRange: { min: 15.0, max: 80.0, default: 30.0 },
    defaultPattern: 'intermittent',
    patternDescription: 'Intermittent - Information alert',
    allowDecimals: true,
  },
  [CriticalAlarmType.HIGH_SPEED]: {
    label: 'High Speed',
    description: 'Alert when vessel speed exceeds safe operating limit.',
    iconName: 'speedometer-outline',
    baseUnit: 'm/s',
    hasMin: false,
    hasMax: true,
    hasWarning: true,
    maxLabel: 'Maximum Speed',
    warningLabel: 'Warning Speed',
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 10.0, max: 50.0, default: 25.0 },
    warningRange: { min: 8.0, max: 45.0, default: 20.0 },
    defaultPattern: 'warble',
    patternDescription: 'Warble - Equipment warning',
    allowDecimals: true,
  },
  
  // === ENGINE ===
  [CriticalAlarmType.ENGINE_OVERHEAT]: {
    label: 'Engine Overheat',
    description: 'Alert when engine temperature exceeds safe operating limits. Prevents engine damage from overheating.',
    iconName: 'thermometer-outline',
    baseUnit: '°C',
    hasMin: false,
    hasMax: true,
    hasWarning: true,
    maxLabel: 'Maximum Temperature',
    warningLabel: 'Warning Temperature',
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 80, max: 120, default: 95 },
    warningRange: { min: 75, max: 110, default: 85 },
    defaultPattern: 'warble',
    patternDescription: 'Warble - ISO Priority 3 equipment warning',
    allowDecimals: false,
  },
  [CriticalAlarmType.ENGINE_LOW_TEMP]: {
    label: 'Engine Low Temperature',
    description: 'Alert when engine temperature is below normal operating range.',
    iconName: 'thermometer-outline',
    baseUnit: '°C',
    hasMin: true,
    hasMax: false,
    hasWarning: true,
    minLabel: 'Minimum Temperature',
    warningLabel: 'Warning Temperature',
    minRange: { min: 20, max: 60, default: 40 },
    maxRange: { min: 0, max: 0, default: 9999 },
    warningRange: { min: 30, max: 70, default: 50 },
    defaultPattern: 'intermittent',
    patternDescription: 'Intermittent - Information',
    allowDecimals: false,
  },
  [CriticalAlarmType.ENGINE_HIGH_RPM]: {
    label: 'Engine High RPM',
    description: 'Alert when engine RPM exceeds safe operating limit.',
    iconName: 'speedometer-outline',
    baseUnit: 'rpm',
    hasMin: false,
    hasMax: true,
    hasWarning: true,
    maxLabel: 'Maximum RPM',
    warningLabel: 'Warning RPM',
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 2000, max: 5000, default: 3600 },
    warningRange: { min: 1800, max: 4500, default: 3300 },
    defaultPattern: 'rapid_pulse',
    patternDescription: 'Rapid pulse - Machinery protection',
    allowDecimals: false,
  },
  [CriticalAlarmType.ENGINE_LOW_OIL_PRESSURE]: {
    label: 'Low Oil Pressure',
    description: 'Critical alert for low engine oil pressure. Immediate attention required.',
    iconName: 'water-outline',
    baseUnit: 'PSI',
    hasMin: true,
    hasMax: false,
    hasWarning: true,
    minLabel: 'Critical Minimum Pressure',
    warningLabel: 'Warning Pressure',
    minRange: { min: 10, max: 40, default: 20 },
    maxRange: { min: 0, max: 0, default: 9999 },
    warningRange: { min: 15, max: 50, default: 30 },
    defaultPattern: 'rapid_pulse',
    patternDescription: 'Rapid pulse - Critical machinery alarm',
    allowDecimals: false,
  },
  
  // === ELECTRICAL ===
  [CriticalAlarmType.LOW_BATTERY]: {
    label: 'Low Battery',
    description: 'Alert when battery voltage drops below safe level. Ensures sufficient power for critical systems.',
    iconName: 'battery-dead-outline',
    baseUnit: 'V',
    hasMin: true,
    hasMax: false,
    hasWarning: true,
    minLabel: 'Critical Minimum Voltage',
    warningLabel: 'Warning Voltage',
    minRange: { min: 10.0, max: 12.5, default: 11.0 },
    maxRange: { min: 0, max: 0, default: 9999 },
    warningRange: { min: 11.0, max: 13.0, default: 12.0 },
    defaultPattern: 'triple_blast',
    patternDescription: 'Triple blast - General alert pattern',
    allowDecimals: true,
  },
  [CriticalAlarmType.HIGH_BATTERY]: {
    label: 'High Battery',
    description: 'Alert when battery voltage exceeds safe limit. Indicates overcharging.',
    iconName: 'battery-charging-outline',
    baseUnit: 'V',
    hasMin: false,
    hasMax: true,
    hasWarning: true,
    maxLabel: 'Maximum Voltage',
    warningLabel: 'Warning Voltage',
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 14.0, max: 16.0, default: 15.0 },
    warningRange: { min: 13.5, max: 15.5, default: 14.5 },
    defaultPattern: 'intermittent',
    patternDescription: 'Intermittent - Equipment warning',
    allowDecimals: true,
  },
  [CriticalAlarmType.LOW_ALTERNATOR]: {
    label: 'Low Alternator Output',
    description: 'Alert when alternator output voltage is below expected charging level.',
    iconName: 'flash-outline',
    baseUnit: 'V',
    hasMin: true,
    hasMax: false,
    hasWarning: true,
    minLabel: 'Minimum Alternator Voltage',
    warningLabel: 'Warning Voltage',
    minRange: { min: 12.5, max: 14.0, default: 13.0 },
    maxRange: { min: 0, max: 0, default: 9999 },
    warningRange: { min: 13.0, max: 14.5, default: 13.5 },
    defaultPattern: 'triple_blast',
    patternDescription: 'Triple blast - Charging system alert',
    allowDecimals: true,
  },
  [CriticalAlarmType.HIGH_CURRENT]: {
    label: 'High Current Draw',
    description: 'Alert when electrical current draw exceeds safe limit.',
    iconName: 'flash-outline',
    baseUnit: 'A',
    hasMin: false,
    hasMax: true,
    hasWarning: true,
    maxLabel: 'Maximum Current',
    warningLabel: 'Warning Current',
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 50, max: 300, default: 150 },
    warningRange: { min: 40, max: 250, default: 120 },
    defaultPattern: 'warble',
    patternDescription: 'Warble - Electrical system warning',
    allowDecimals: false,
  },
  
  // === WIND ===
  [CriticalAlarmType.HIGH_WIND]: {
    label: 'High Wind Speed',
    description: 'Alert when wind speed exceeds safe operating conditions.',
    iconName: 'cloudy-outline',
    baseUnit: 'm/s',
    hasMin: false,
    hasMax: true,
    hasWarning: true,
    maxLabel: 'Maximum Wind Speed',
    warningLabel: 'Warning Wind Speed',
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 20, max: 60, default: 35 },
    warningRange: { min: 15, max: 50, default: 25 },
    defaultPattern: 'warble',
    patternDescription: 'Warble - Weather warning',
    allowDecimals: true,
  },
  [CriticalAlarmType.WIND_GUST]: {
    label: 'Wind Gust',
    description: 'Alert on sudden wind gusts that may affect vessel stability.',
    iconName: 'cloudy-outline',
    baseUnit: 'm/s',
    hasMin: false,
    hasMax: true,
    hasWarning: false,
    maxLabel: 'Maximum Gust Speed',
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 25, max: 70, default: 45 },
    warningRange: { min: 0, max: 0, default: 9999 },
    defaultPattern: 'rapid_pulse',
    patternDescription: 'Rapid pulse - Immediate weather threat',
    allowDecimals: false,
  },
  
  // === SYSTEM ===
  [CriticalAlarmType.AUTOPILOT_FAILURE]: {
    label: 'Autopilot Failure',
    description: 'Alert on autopilot disconnection or malfunction. Critical for safe navigation when using autopilot.',
    iconName: 'swap-horizontal-outline',
    baseUnit: '',
    hasMin: false,
    hasMax: false,
    hasWarning: false,
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 0, max: 0, default: 9999 },
    warningRange: { min: 0, max: 0, default: 9999 },
    defaultPattern: 'morse_u',
    patternDescription: 'Morse "U" - Maritime standard for "You are in danger"',
    allowDecimals: false,
  },
  [CriticalAlarmType.GPS_LOSS]: {
    label: 'GPS Signal Loss',
    description: 'Alert when GPS signal quality degrades or is lost. Essential for navigation safety.',
    iconName: 'navigate-outline',
    baseUnit: 's',
    hasMin: false,
    hasMax: true,
    hasWarning: false,
    maxLabel: 'Signal Loss Timeout',
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 5, max: 60, default: 10 },
    warningRange: { min: 0, max: 0, default: 9999 },
    defaultPattern: 'intermittent',
    patternDescription: 'Intermittent - Navigation system alert',
    allowDecimals: false,
  },
  
  // === TANKS ===
  [CriticalAlarmType.LOW_FUEL]: {
    label: 'Low Fuel Level',
    description: 'Alert when fuel level drops below safe reserve.',
    iconName: 'beaker-outline',
    baseUnit: '%',
    hasMin: true,
    hasMax: false,
    hasWarning: true,
    minLabel: 'Critical Minimum Level',
    warningLabel: 'Warning Level',
    minRange: { min: 5, max: 30, default: 10 },
    maxRange: { min: 0, max: 0, default: 9999 },
    warningRange: { min: 10, max: 40, default: 25 },
    defaultPattern: 'triple_blast',
    patternDescription: 'Triple blast - Fuel system alert',
    allowDecimals: false,
  },
  [CriticalAlarmType.LOW_WATER]: {
    label: 'Low Fresh Water',
    description: 'Alert when fresh water tank level is low.',
    iconName: 'water-outline',
    baseUnit: '%',
    hasMin: true,
    hasMax: false,
    hasWarning: true,
    minLabel: 'Critical Minimum Level',
    warningLabel: 'Warning Level',
    minRange: { min: 5, max: 30, default: 10 },
    maxRange: { min: 0, max: 0, default: 9999 },
    warningRange: { min: 10, max: 40, default: 25 },
    defaultPattern: 'intermittent',
    patternDescription: 'Intermittent - Tank level alert',
    allowDecimals: false,
  },
  [CriticalAlarmType.HIGH_WASTE_WATER]: {
    label: 'High Waste Water',
    description: 'Alert when waste water tank is approaching full capacity.',
    iconName: 'warning-outline',
    baseUnit: '%',
    hasMin: false,
    hasMax: true,
    hasWarning: true,
    maxLabel: 'Maximum Level',
    warningLabel: 'Warning Level',
    minRange: { min: 0, max: 0, default: 9999 },
    maxRange: { min: 70, max: 95, default: 90 },
    warningRange: { min: 60, max: 90, default: 75 },
    defaultPattern: 'intermittent',
    patternDescription: 'Intermittent - Tank level alert',
  },
};

interface AlarmConfigDialogProps {
  visible: boolean;
  onClose: () => void;
}

type ViewMode = 'list' | 'detail';

export const AlarmConfigDialog: React.FC<AlarmConfigDialogProps> = ({
  visible,
  onClose,
}) => {
  const theme = useTheme();
  const styles = useMemo(() => createStyles(theme), [theme]);
  const [viewMode, setViewMode] = useState<ViewMode>('list');
  const [selectedAlarmType, setSelectedAlarmType] = useState<CriticalAlarmType | null>(null);
  const [loading, setLoading] = useState(true);
  const [configs, setConfigs] = useState<Map<CriticalAlarmType, CriticalAlarmConfig>>(new Map());
  
  // Detail view state
  const [config, setConfig] = useState<CriticalAlarmConfig | null>(null);
  const [hasChanges, setHasChanges] = useState(false);
  const [saving, setSaving] = useState(false);
  
  // Confirmation dialog state
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [confirmDialogData, setConfirmDialogData] = useState<{
    title: string;
    message: string;
    onConfirm: () => void;
  } | null>(null);

  // Presentation hooks for unit conversion (called at component level)
  const depthPresentation = useDataPresentation('depth');
  const speedPresentation = useDataPresentation('speed');
  const temperaturePresentation = useDataPresentation('temperature');
  const voltagePresentation = useDataPresentation('voltage');
  const currentPresentation = useDataPresentation('current');

  // Load all alarm configurations
  useEffect(() => {
    if (visible) {
      loadConfigurations();
      
      // Web-specific: Remove green overlay elements from DOM
      if (typeof window !== 'undefined' && typeof document !== 'undefined') {
        const removeGreenElements = () => {
          try {
            const elements = document.querySelectorAll('div[style*="rgb(0, 150, 136)"]');
            elements.forEach(el => {
              if (el instanceof HTMLElement) {
                el.style.display = 'none';
                el.style.visibility = 'hidden';
                el.style.opacity = '0';
                el.style.width = '0';
                el.style.height = '0';
              }
            });
          } catch (error) {
            // Silently ignore on non-web platforms
          }
        };
        
        // Run multiple times to catch dynamically added elements
        removeGreenElements();
        setTimeout(removeGreenElements, 100);
        setTimeout(removeGreenElements, 500);
        const interval = setInterval(removeGreenElements, 1000);
        
        return () => clearInterval(interval);
      }
    }
  }, [visible]);

  const loadConfigurations = async () => {
    setLoading(true);
    try {
      const loadedConfigs = new Map<CriticalAlarmType, CriticalAlarmConfig>();

      for (const alarm of ALARM_LIST) {
        const config = alarmConfig.getAlarmConfig(alarm.type);
        if (config) {
          loadedConfigs.set(alarm.type, config);
        }
      }

      setConfigs(loadedConfigs);
    } catch (error) {
      console.error('[AlarmConfigDialog] Failed to load configurations:', error);
      Alert.alert('Error', 'Failed to load alarm settings');
    } finally {
      setLoading(false);
    }
  };

  // Quick toggle from list view
  const handleQuickToggle = async (type: CriticalAlarmType, enabled: boolean) => {
    if (!enabled && !canDisableAlarm(type)) {
      Alert.alert(
        'Critical Safety Alarm',
        'This alarm cannot be disabled for safety compliance.',
        [{ text: 'OK' }]
      );
      return;
    }

    try {
      const result = await alarmConfig.setAlarmEnabled(type, enabled);
      if (result.success) {
        setConfigs(prev => {
          const updated = new Map(prev);
          const config = updated.get(type);
          if (config) {
            updated.set(type, { ...config, enabled });
          }
          return updated;
        });
      }
    } catch (error) {
      console.error('[AlarmConfigDialog] Failed to toggle alarm:', error);
      Alert.alert('Error', 'Failed to update alarm');
    }
  };

  // Navigate to detail view
  const handleNavigateToDetail = (type: CriticalAlarmType) => {
    setSelectedAlarmType(type);
    const alarmConfig = configs.get(type);
    if (alarmConfig) {
      setConfig(alarmConfig);
      setViewMode('detail');
      setHasChanges(false);
    }
  };

  // Navigate back to list
  const handleBackToList = async () => {
    if (hasChanges) {
      if (Platform.OS === 'web') {
        const choice = window.confirm(
          'You have unsaved changes. Click OK to save, or Cancel to discard.'
        );
        if (choice) {
          await handleSave(true); // skipNavigation = true
          setViewMode('list');
          setSelectedAlarmType(null);
          setConfig(null);
        } else {
          setViewMode('list');
          setSelectedAlarmType(null);
          setConfig(null);
          setHasChanges(false);
        }
      } else {
        Alert.alert(
          'Unsaved Changes',
          'You have unsaved changes. Do you want to save before going back?',
          [
            { text: 'Discard', style: 'destructive', onPress: () => {
              setViewMode('list');
              setSelectedAlarmType(null);
              setConfig(null);
              setHasChanges(false);
            }},
            { text: 'Save', onPress: async () => {
              await handleSave();
              setViewMode('list');
              setSelectedAlarmType(null);
              setConfig(null);
            }},
            { text: 'Cancel', style: 'cancel' },
          ]
        );
      }
    } else {
      setViewMode('list');
      setSelectedAlarmType(null);
      setConfig(null);
    }
  };

  // Save detail changes
  const handleSave = async (skipNavigation = false) => {
    if (!config || !selectedAlarmType) return;

    // Validate threshold ordering
    const metadata = ALARM_METADATA[selectedAlarmType];
    if (metadata) {
      // For alarms with both min and warning (like SHALLOW_WATER): warning should be greater than min
      if (metadata.hasMin && metadata.hasWarning && 
          config.thresholds.min !== 9999 && config.thresholds.warning !== 9999 &&
          config.thresholds.warning <= config.thresholds.min) {
        if (Platform.OS === 'web') {
          window.alert('Invalid Threshold Order\n\nWarning threshold must be greater than critical minimum threshold.');
        } else {
          Alert.alert(
            'Invalid Threshold Order',
            'Warning threshold must be greater than critical minimum threshold.',
            [{ text: 'OK' }]
          );
        }
        return;
      }

      // For alarms with both max and warning (like HIGH_WASTE_WATER): warning should be less than max
      if (metadata.hasMax && metadata.hasWarning &&
          config.thresholds.max !== 9999 && config.thresholds.warning !== 9999 &&
          config.thresholds.warning >= config.thresholds.max) {
        if (Platform.OS === 'web') {
          window.alert('Invalid Threshold Order\n\nWarning threshold must be less than critical maximum threshold.');
        } else {
          Alert.alert(
            'Invalid Threshold Order',
            'Warning threshold must be less than critical maximum threshold.',
            [{ text: 'OK' }]
          );
        }
        return;
      }
    }

    setSaving(true);
    try {
      const result = await alarmConfig.updateAlarmConfig(selectedAlarmType, config);
      logger.alarm('Save result:', result);
      if (result.success) {
        setConfigs(prev => {
          const updated = new Map(prev);
          updated.set(selectedAlarmType, config);
          return updated;
        });
        setHasChanges(false);
        
        // Configuration automatically propagates to widgets via CriticalAlarmConfiguration event system
        logger.alarm('Alarm configuration saved:', selectedAlarmType, config.thresholds);
        
        // Navigate back to list view (unless caller will handle it)
        logger.alarm('skipNavigation:', skipNavigation);
        if (!skipNavigation) {
          logger.alarm('Navigating back to list...');
          setViewMode('list');
          setSelectedAlarmType(null);
          setConfig(null);
          logger.alarm('Navigation complete');
        }
      } else {
        const errorMsg = result.errors?.join(', ') || 'Failed to save alarm configuration';
        if (Platform.OS === 'web') {
          window.alert(errorMsg);
        } else {
          Alert.alert('Error', errorMsg);
        }
      }
    } catch (error) {
      console.error('[AlarmConfigDialog] Failed to save:', error);
      if (Platform.OS === 'web') {
        window.alert('Failed to save alarm configuration');
      } else {
        Alert.alert('Error', 'Failed to save alarm configuration');
      }
    } finally {
      setSaving(false);
    }
  };

  // No longer need to sync to alarm store - CriticalAlarmConfiguration is the single source of truth
  // Widgets now use useAlarmThresholds hook which queries CriticalAlarmConfiguration directly

  // Handle close
  const handleClose = () => {
    if (viewMode === 'detail' && hasChanges) {
      handleBackToList();
    } else {
      onClose();
    }
  };

  // Reset all alarms
  const handleResetAll = () => {
    Alert.alert(
      'Reset All Alarms',
      'Are you sure you want to reset all alarm settings to their default values?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Reset',
          style: 'destructive',
          onPress: async () => {
            try {
              for (const alarm of ALARM_LIST) {
                await alarmConfig.resetToDefault(alarm.type);
              }
              await loadConfigurations();
              Alert.alert('Success', 'All alarms reset to defaults', [{ text: 'OK' }]);
            } catch (error) {
              console.error('[AlarmConfigDialog] Failed to reset:', error);
              Alert.alert('Error', 'Failed to reset alarms');
            }
          },
        },
      ]
    );
  };

  // Get alarm summary text (without unit conversion for list view - uses baseUnit)
  // Unit conversion happens in detail view where presentation hooks are available
  const getAlarmSummary = (type: CriticalAlarmType, config: CriticalAlarmConfig | undefined): string => {
    if (!config) return 'Not configured';
    if (!config.enabled) return '';

    const metadata = ALARM_METADATA[type];
    if (!metadata) return '';

    // System alarms without thresholds
    if (type === CriticalAlarmType.AUTOPILOT_FAILURE) {
      return 'Enabled';
    }

    // Build summary based on active thresholds (showing reference units)
    const parts: string[] = [];
    const decimals = metadata.allowDecimals === false ? 0 : 1;
    
    if (metadata.hasMin && config.thresholds?.min != null && config.thresholds.min !== 9999) {
      parts.push(`Min: ${config.thresholds.min.toFixed(decimals)}${metadata.baseUnit}`);
    }
    
    if (metadata.hasMax && config.thresholds?.max != null && config.thresholds.max !== 9999) {
      parts.push(`Max: ${config.thresholds.max.toFixed(decimals)}${metadata.baseUnit}`);
    }
    
    if (metadata.hasWarning && config.thresholds?.warning != null && config.thresholds.warning !== 9999) {
      parts.push(`Warn: ${config.thresholds.warning.toFixed(decimals)}${metadata.baseUnit}`);
    }

    return parts.join(' • ') || 'Configured';
  };

  // Render list view
  const renderListView = () => {
    if (loading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.text} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>Loading alarms...</Text>
        </View>
      );
    }

    return (
      <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
        <Text style={[styles.description, { color: theme.textSecondary }]}>
          Configure alarm thresholds for all marine sensors. Tap any alarm for detailed settings.
        </Text>
        {ALARM_CATEGORIES.map((category) => (
          <View key={category.title} style={styles.categorySection}>
            <Text style={[styles.categoryTitle, { color: theme.text }]}>{category.title}</Text>{category.alarms.map((alarm) => {
              const alarmConfig = configs.get(alarm.type);
              const isEnabled = alarmConfig?.enabled ?? false;
              const summary = getAlarmSummary(alarm.type, alarmConfig);
              return (
                <Pressable
                  key={alarm.type}
                  style={[styles.alarmCard, { backgroundColor: theme.surface, borderColor: theme.border }]}
                  onPress={() => handleNavigateToDetail(alarm.type)}>
                  <View style={styles.alarmIcon}>
                    <UniversalIcon name={alarm.iconName} size={28} color={theme.text} />
                  </View>
                  <View style={styles.alarmInfo}>
                    <Text style={[styles.alarmLabel, { color: theme.text }]}>{alarm.label}</Text>
                    {summary && <Text style={[styles.alarmSummary, { color: theme.textSecondary }]}>{summary}</Text>}
                  </View>
                  <View style={[styles.statusDot, { backgroundColor: isEnabled ? theme.success : theme.error }]} />
                  <UniversalIcon name="chevron-forward-outline" size={20} color={theme.textSecondary} />
                </Pressable>
              );
            })}
          </View>
        ))}

        <Pressable
          style={[styles.resetButton, { borderColor: theme.border }]}
          onPress={handleResetAll}
        >
          <UniversalIcon name="refresh-outline" size={20} color={theme.error} />
          <Text style={[styles.resetButtonText, { color: theme.error }]}>Reset All to Defaults</Text>
        </Pressable>
      </ScrollView>
    );
  };

  // Render detail view
  const renderDetailView = () => {
    if (!config || !selectedAlarmType) return null;

    const metadata = ALARM_METADATA[selectedAlarmType];
    if (!metadata) return null;

    // Get presentation for unit conversion (use pre-initialized hooks)
    const category = ALARM_TYPE_TO_CATEGORY[selectedAlarmType];
    let presentation = null;
    
    if (category === 'depth') presentation = depthPresentation;
    else if (category === 'speed') presentation = speedPresentation;
    else if (category === 'temperature') presentation = temperaturePresentation;
    else if (category === 'voltage') presentation = voltagePresentation;
    else if (category === 'current') presentation = currentPresentation;
    
    // Use display unit from presentation or fallback to base unit
    const displayUnit = presentation?.presentation?.symbol || metadata.baseUnit;
    
    // Conversion helpers
    const toDisplay = (referenceValue: number) => 
      presentation ? presentation.convert(referenceValue) : referenceValue;
    const toReference = (displayValue: number) => 
      presentation ? presentation.convertBack(displayValue) : displayValue;

    const updateConfig = (updates: Partial<CriticalAlarmConfig>) => {
      console.log('[AlarmConfigDialog] updateConfig called with:', updates);
      console.log('[AlarmConfigDialog] Current config.enabled:', config?.enabled);
      console.log('[AlarmConfigDialog] selectedAlarmType:', selectedAlarmType);
      console.log('[AlarmConfigDialog] canDisableAlarm:', canDisableAlarm(selectedAlarmType));
      
      // If disabling a critical alarm, show confirmation dialog
      if (updates.enabled === false && !canDisableAlarm(selectedAlarmType)) {
        console.log('[AlarmConfigDialog] Showing confirmation dialog for critical alarm');
        
        // Use custom confirmation dialog (works on all platforms)
        setConfirmDialogData({
          title: 'Disable Critical Safety Alarm?',
          message: `${metadata.label} is a critical safety alarm. Disabling it may put your vessel at risk.\n\nAre you sure you want to disable this alarm?`,
          onConfirm: () => {
            console.log('[AlarmConfigDialog] User confirmed, disabling alarm');
            setConfig(prev => {
              const newConfig = prev ? { ...prev, ...updates } : null;
              console.log('[AlarmConfigDialog] New config:', newConfig);
              return newConfig;
            });
            setHasChanges(true);
            setShowConfirmDialog(false);
          },
        });
        setShowConfirmDialog(true);
        return;
      }
      
      // For all other changes, update immediately
      console.log('[AlarmConfigDialog] Updating config immediately');
      setConfig(prev => {
        const newConfig = prev ? { ...prev, ...updates } : null;
        console.log('[AlarmConfigDialog] New config:', newConfig);
        return newConfig;
      });
      setHasChanges(true);
    };

    return (
      <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
        <View style={styles.iconSection}>
          <View style={[styles.iconContainer, { backgroundColor: theme.surface }]}>
            <UniversalIcon name={metadata.iconName} size={48} color={theme.textSecondary} />
          </View>
          <Text style={[styles.detailDescription, { color: theme.textSecondary }]}>
            {metadata.description}
          </Text>
        </View>

        <View style={[styles.section, { backgroundColor: theme.surface, borderColor: theme.border }]}>
          <View style={styles.sectionRow}>
            <View style={{ flex: 1 }}>
              <Text style={[styles.sectionLabel, { color: theme.text }]}>Enable Alarm</Text>
              {!canDisableAlarm(selectedAlarmType) && (
                <Text style={[styles.hint, { color: theme.textSecondary, marginTop: 2 }]}>
                  Critical safety alarm - confirmation required to disable
                </Text>
              )}
            </View>
            <LocalSwitch
              value={config.enabled}
              onValueChange={(value) => updateConfig({ enabled: value })}
              trackColor={{ false: theme.border, true: theme.interactive }}
            />
          </View>
        </View>

        {config.enabled && metadata && (metadata.hasMin || metadata.hasMax || metadata.hasWarning) && (
          <View style={[styles.section, { backgroundColor: theme.surface, borderColor: theme.border }]}>
            <Text style={[styles.sectionTitle, { color: theme.text }]}>Threshold Configuration</Text>
            {metadata.hasMin && (() => {
              // Convert reference values to display units
              const minValue = config.thresholds?.min ?? metadata.minRange.default;
              const minDisplay = toDisplay(minValue === 9999 ? metadata.minRange.default : minValue);
              const rangeMinDisplay = toDisplay(metadata.minRange.min);
              const rangeMaxDisplay = toDisplay(metadata.minRange.max);
              const rangeSize = rangeMaxDisplay - rangeMinDisplay;
              const step = getSmartStep(displayUnit, rangeSize);
              
              return (
                <View style={styles.thresholdSection}>
                  <Text style={[styles.thresholdLabel, { color: theme.text }]}>
                    {metadata.minLabel} ({displayUnit})
                  </Text>
                  <View style={styles.thresholdControl}>
                    <Pressable
                      style={[styles.adjustButton, { borderColor: theme.border, backgroundColor: theme.background }]}
                      onPress={() => {
                        const newDisplayValue = Math.max(rangeMinDisplay, minDisplay - step);
                        const newReferenceValue = toReference(newDisplayValue);
                        const precision = metadata.allowDecimals === false ? 0 : (step < 1 ? 1 : 0);
                        updateConfig({
                          thresholds: { ...config.thresholds, min: parseFloat(newReferenceValue.toFixed(precision)) }
                        });
                      }}
                    >
                      <Text style={[styles.adjustButtonText, { color: theme.text }]}>−</Text>
                    </Pressable>
                    
                    <TextInput
                      style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
                      value={metadata.allowDecimals === false ? String(Math.round(minDisplay || 0)) : String((minDisplay || 0).toFixed(1))}
                      onChangeText={(text) => {
                        const displayValue = metadata.allowDecimals === false ? parseInt(text) : parseFloat(text);
                        if (!isNaN(displayValue) && displayValue >= rangeMinDisplay && displayValue <= rangeMaxDisplay) {
                          const referenceValue = toReference(displayValue);
                          updateConfig({
                            thresholds: { ...config.thresholds, min: referenceValue }
                          });
                        }
                      }}
                      keyboardType={metadata.allowDecimals === false ? "number-pad" : "decimal-pad"}
                      editable={config.enabled}
                    />
                    
                    <Pressable
                      style={[styles.adjustButton, { borderColor: theme.border, backgroundColor: theme.background }]}
                      onPress={() => {
                        const newDisplayValue = Math.min(rangeMaxDisplay, minDisplay + step);
                        const newReferenceValue = toReference(newDisplayValue);
                        const precision = metadata.allowDecimals === false ? 0 : (step < 1 ? 1 : 0);
                        updateConfig({
                          thresholds: { ...config.thresholds, min: parseFloat(newReferenceValue.toFixed(precision)) }
                        });
                      }}
                    >
                      <Text style={[styles.adjustButtonText, { color: theme.text }]}>+</Text>
                    </Pressable>
                  </View>
                  <Text style={[styles.hint, { color: theme.textSecondary }]}>
                    Range: {rangeMinDisplay.toFixed(metadata.allowDecimals === false ? 0 : 1)} - {rangeMaxDisplay.toFixed(metadata.allowDecimals === false ? 0 : 1)} {displayUnit}
                  </Text>
                </View>
              );
            })()}

            {metadata.hasMax && (() => {
              // Convert reference values to display units
              const maxValue = config.thresholds?.max ?? metadata.maxRange.default;
              const maxDisplay = toDisplay(maxValue === 9999 ? metadata.maxRange.default : maxValue);
              const rangeMinDisplay = toDisplay(metadata.maxRange.min);
              const rangeMaxDisplay = toDisplay(metadata.maxRange.max);
              const rangeSize = rangeMaxDisplay - rangeMinDisplay;
              const step = getSmartStep(displayUnit, rangeSize);
              
              return (
                <View style={styles.thresholdSection}>
                  <Text style={[styles.thresholdLabel, { color: theme.text }]}>
                    {metadata.maxLabel} ({displayUnit})
                  </Text>
                  <View style={styles.thresholdControl}>
                    <Pressable
                      style={[styles.adjustButton, { borderColor: theme.border, backgroundColor: theme.background }]}
                      onPress={() => {
                        const newDisplayValue = Math.max(rangeMinDisplay, maxDisplay - step);
                        const newReferenceValue = toReference(newDisplayValue);
                        const precision = metadata.allowDecimals === false ? 0 : (step < 1 ? 1 : 0);
                        updateConfig({
                          thresholds: { ...config.thresholds, max: parseFloat(newReferenceValue.toFixed(precision)) }
                        });
                      }}
                    >
                      <Text style={[styles.adjustButtonText, { color: theme.text }]}>−</Text>
                    </Pressable>
                    
                    <TextInput
                      style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
                      value={metadata.allowDecimals === false ? String(Math.round(maxDisplay || 0)) : String((maxDisplay || 0).toFixed(1))}
                      onChangeText={(text) => {
                        const displayValue = metadata.allowDecimals === false ? parseInt(text) : parseFloat(text);
                        if (!isNaN(displayValue) && displayValue >= rangeMinDisplay && displayValue <= rangeMaxDisplay) {
                          const referenceValue = toReference(displayValue);
                          updateConfig({
                            thresholds: { ...config.thresholds, max: referenceValue }
                          });
                        }
                      }}
                      keyboardType={metadata.allowDecimals === false ? "number-pad" : "decimal-pad"}
                      editable={config.enabled}
                    />
                    
                    <Pressable
                      style={[styles.adjustButton, { borderColor: theme.border, backgroundColor: theme.background }]}
                      onPress={() => {
                        const newDisplayValue = Math.min(rangeMaxDisplay, maxDisplay + step);
                        const newReferenceValue = toReference(newDisplayValue);
                        const precision = metadata.allowDecimals === false ? 0 : (step < 1 ? 1 : 0);
                        updateConfig({
                          thresholds: { ...config.thresholds, max: parseFloat(newReferenceValue.toFixed(precision)) }
                        });
                      }}
                    >
                      <Text style={[styles.adjustButtonText, { color: theme.text }]}>+</Text>
                    </Pressable>
                  </View>
                  <Text style={[styles.hint, { color: theme.textSecondary }]}>
                    Range: {rangeMinDisplay.toFixed(metadata.allowDecimals === false ? 0 : 1)} - {rangeMaxDisplay.toFixed(metadata.allowDecimals === false ? 0 : 1)} {displayUnit}
                  </Text>
                </View>
              );
            })()}

            {metadata.hasWarning && (() => {
              // Convert reference values to display units
              const warningValue = config.thresholds?.warning ?? metadata.warningRange.default;
              const warningDisplay = toDisplay(warningValue === 9999 ? metadata.warningRange.default : warningValue);
              const rangeMinDisplay = toDisplay(metadata.warningRange.min);
              const rangeMaxDisplay = toDisplay(metadata.warningRange.max);
              const rangeSize = rangeMaxDisplay - rangeMinDisplay;
              const step = getSmartStep(displayUnit, rangeSize);
              
              return (
                <View style={styles.thresholdSection}>
                  <Text style={[styles.thresholdLabel, { color: theme.text }]}>
                    {metadata.warningLabel} ({displayUnit})
                  </Text>
                  <View style={styles.thresholdControl}>
                    <Pressable
                      style={[styles.adjustButton, { borderColor: theme.border, backgroundColor: theme.background }]}
                      onPress={() => {
                        const newDisplayValue = Math.max(rangeMinDisplay, warningDisplay - step);
                        const newReferenceValue = toReference(newDisplayValue);
                        const precision = metadata.allowDecimals === false ? 0 : (step < 1 ? 1 : 0);
                        updateConfig({
                          thresholds: { ...config.thresholds, warning: parseFloat(newReferenceValue.toFixed(precision)) }
                        });
                      }}
                    >
                      <Text style={[styles.adjustButtonText, { color: theme.text }]}>−</Text>
                    </Pressable>
                    
                    <TextInput
                      style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
                      value={metadata.allowDecimals === false ? String(Math.round(warningDisplay || 0)) : String((warningDisplay || 0).toFixed(1))}
                      onChangeText={(text) => {
                        const displayValue = metadata.allowDecimals === false ? parseInt(text) : parseFloat(text);
                        if (!isNaN(displayValue) && displayValue >= rangeMinDisplay && displayValue <= rangeMaxDisplay) {
                          const referenceValue = toReference(displayValue);
                          updateConfig({
                            thresholds: { ...config.thresholds, warning: referenceValue }
                          });
                        }
                      }}
                      keyboardType={metadata.allowDecimals === false ? "number-pad" : "decimal-pad"}
                      editable={config.enabled}
                    />
                    
                    <Pressable
                      style={[styles.adjustButton, { borderColor: theme.border, backgroundColor: theme.background }]}
                      onPress={() => {
                        const newDisplayValue = Math.min(rangeMaxDisplay, warningDisplay + step);
                        const newReferenceValue = toReference(newDisplayValue);
                        const precision = metadata.allowDecimals === false ? 0 : (step < 1 ? 1 : 0);
                        updateConfig({
                          thresholds: { ...config.thresholds, warning: parseFloat(newReferenceValue.toFixed(precision)) }
                        });
                      }}
                    >
                      <Text style={[styles.adjustButtonText, { color: theme.text }]}>+</Text>
                    </Pressable>
                  </View>
                  <Text style={[styles.hint, { color: theme.textSecondary }]}>
                    Range: {rangeMinDisplay.toFixed(metadata.allowDecimals === false ? 0 : 1)} - {rangeMaxDisplay.toFixed(metadata.allowDecimals === false ? 0 : 1)} {displayUnit}
                  </Text>
                </View>
              );
            })()}
          </View>
        )}

        {config.enabled && (
          <View style={[styles.section, { backgroundColor: theme.surface, borderColor: theme.border }]}>
            <View style={styles.row}>
              <View style={{ flex: 1 }}>
                <Text style={[styles.sectionTitle, { color: theme.text, marginBottom: 4 }]}>
                  Audio Alerts
                </Text>
                <Text style={[styles.patternDescription, { fontSize: 13, marginBottom: 0 }]}>
                  Enable audible alarm sounds
                </Text>
              </View>
              <LocalSwitch
                value={config.audioEnabled}
                onValueChange={(enabled) => updateConfig({ audioEnabled: enabled })}
                trackColor={{ false: theme.border, true: theme.interactive }}
              />
            </View>
          </View>
        )}

        {config.enabled && config.audioEnabled && (
          <View style={[styles.section, { backgroundColor: theme.surface, borderColor: theme.border }]}>
            <Text style={[styles.sectionTitle, { color: theme.text }]}>Alarm Sound Pattern</Text>
            <Text style={[styles.patternDescription, { color: theme.textSecondary }]}>
              {metadata.patternDescription}
            </Text>
            <View style={styles.patternOptions}>
              {[
                { value: 'rapid_pulse', label: 'Rapid Pulse', description: 'ISO Priority 1 - Immediate danger' },
                { value: 'morse_u', label: 'Morse "U" (·· —)', description: 'ISO Priority 2 - "You are in danger"' },
                { value: 'warble', label: 'Warble', description: 'ISO Priority 3 - Equipment warning' },
                { value: 'triple_blast', label: 'Triple Blast', description: 'ISO Priority 4 - General alert' },
                { value: 'intermittent', label: 'Intermittent', description: 'ISO Priority 5 - Information' },
                { value: 'continuous_descending', label: 'Descending', description: 'Signal degradation (custom)' },
              ].map((pattern) => (
                <Pressable
                  key={pattern.value}
                  style={[
                    styles.patternOption,
                    { 
                      backgroundColor: theme.background,
                      borderColor: config.audioPattern === pattern.value ? theme.primary : theme.border,
                      borderWidth: config.audioPattern === pattern.value ? 2 : 1,
                    }
                  ]}
                  onPress={() => updateConfig({ audioPattern: pattern.value as any })}
                >
                  <View style={styles.patternOptionContent}>
                    <View style={styles.patternRadio}>
                      {config.audioPattern === pattern.value && (
                        <View style={[styles.patternRadioSelected, { backgroundColor: theme.primary }]} />
                      )}
                    </View>
                    <View style={styles.patternText}>
                      <Text style={[styles.patternLabel, { color: theme.text }]}>
                        {pattern.label}
                      </Text>
                      <Text style={[styles.patternDesc, { color: theme.textSecondary }]}>
                        {pattern.description}
                      </Text>
                    </View>
                  </View>
                </Pressable>
              ))}
            </View>
          </View>
        )}

        {config.enabled && config.audioEnabled && (
          <Pressable
            style={[styles.testButton, { backgroundColor: theme.primary, opacity: config.enabled ? 1 : 0.5 }]}
            onPress={async () => {
              try {
                const played = await audioManager.testAlarmSound(
                  selectedAlarmType,
                  AlarmEscalationLevel.WARNING,
                  3000,
                  config.audioPattern
                );
                if (!played) {
                  Alert.alert('Test Failed', 'Failed to play alarm sound. Check audio permissions.');
                }
              } catch (error) {
                Alert.alert('Error', 'Failed to test alarm');
              }
            }}
            disabled={!config.enabled}
          >
            <UniversalIcon name="volume-high-outline" size={24} color={theme.background} />
            <Text style={[styles.testButtonText, { color: theme.background }]}>Test Alarm Sound</Text>
          </Pressable>
        )}
      </ScrollView>
    );
  };

  return (
    <Modal
      visible={visible}
      animationType="slide"
      presentationStyle="pageSheet"
      onRequestClose={handleClose}
    >
      <View style={[styles.container, { backgroundColor: theme.background }]}>
        <View style={styles.dragHandle} />
        <View style={[styles.header, { borderBottomColor: theme.border }]}>
          <TouchableOpacity
            onPress={viewMode === 'detail' ? handleBackToList : handleClose}
            style={styles.headerButton}
          >
            <Text style={[styles.headerButtonText, { color: theme.text }]}>
              {viewMode === 'detail' ? 'Back' : 'Done'}
            </Text>
          </TouchableOpacity>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            {viewMode === 'detail' && selectedAlarmType
              ? ALARM_METADATA[selectedAlarmType]?.label
              : 'Alarms'}
          </Text>
          {viewMode === 'detail' ? (
            <TouchableOpacity
              onPress={() => handleSave()}
              style={styles.headerButton}
              disabled={!hasChanges || saving}
            >
              {saving ? (
                <ActivityIndicator size="small" color={theme.primary} />
              ) : (
                <Text
                  style={[
                    styles.headerButtonText,
                    {
                      color: hasChanges ? theme.primary : theme.textSecondary,
                      fontWeight: hasChanges ? '600' : '400',
                    },
                  ]}
                >
                  Save
                </Text>
              )}
            </TouchableOpacity>
          ) : (
            <View style={styles.headerButton} />
          )}
        </View>
        {viewMode === 'list' ? renderListView() : renderDetailView()}
      </View>
      
      {/* Custom Confirmation Dialog */}
      {showConfirmDialog && confirmDialogData && (
        <View style={styles.confirmDialogOverlay}>
          <View style={[styles.confirmDialog, { backgroundColor: theme.surface }]}>
            <Text style={[styles.confirmDialogTitle, { color: theme.text }]}>
              {confirmDialogData.title}
            </Text>
            <Text style={[styles.confirmDialogMessage, { color: theme.textSecondary }]}>
              {confirmDialogData.message}
            </Text>
            <View style={styles.confirmDialogButtons}>
              <Pressable
                style={[styles.confirmDialogButton, { backgroundColor: theme.border }]}
                onPress={() => {
                  setShowConfirmDialog(false);
                  setConfirmDialogData(null);
                }}
              >
                <Text style={[styles.confirmDialogButtonText, { color: theme.text }]}>
                  Cancel
                </Text>
              </Pressable>
              <Pressable
                style={[styles.confirmDialogButton, { backgroundColor: theme.error }]}
                onPress={confirmDialogData.onConfirm}
              >
                <Text style={[styles.confirmDialogButtonText, { color: '#FFFFFF' }]}>
                  Disable
                </Text>
              </Pressable>
            </View>
          </View>
        </View>
      )}
    </Modal>
  );
};

const createStyles = (theme: ThemeColors) => StyleSheet.create({
  container: {
    flex: 1,
  },
  dragHandle: {
    width: 36,
    height: 5,
    backgroundColor: theme.overlay,
    borderRadius: 3,
    alignSelf: 'center',
    marginTop: 5,
    marginBottom: 5,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  headerButton: {
    padding: 8,
    minWidth: 60,
  },
  headerButtonText: {
    fontSize: 17,
    fontWeight: '400',
  },
  headerTitle: {
    fontSize: 17,
    fontWeight: '600',
    flex: 1,
    textAlign: 'center',
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
  },
  description: {
    fontSize: 15,
    marginBottom: 16,
    textAlign: 'center',
  },
  categorySection: {
    marginBottom: 24,
  },
  categoryTitle: {
    fontSize: 15,
    fontWeight: '700',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
    marginBottom: 12,
    paddingHorizontal: 4,
  },
  alarmCard: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 10,
    borderWidth: 1,
    marginBottom: 12,
  },
  alarmIcon: {
    marginRight: 16,
  },
  alarmInfo: {
    flex: 1,
  },
  alarmLabel: {
    fontSize: 17,
    fontWeight: '600',
  },
  statusDot: {
    width: 12,
    height: 12,
    borderRadius: 6,
    marginRight: 12,
  },
  alarmSummary: {
    fontSize: 14,
  },
  resetButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderRadius: 10,
    borderWidth: 1,
    marginTop: 8,
    gap: 8,
  },
  resetButtonText: {
    fontSize: 16,
    fontWeight: '500',
  },
  iconSection: {
    alignItems: 'center',
    marginBottom: 24,
  },
  iconContainer: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
  },
  detailDescription: {
    fontSize: 15,
    lineHeight: 22,
    textAlign: 'center',
  },
  section: {
    padding: 16,
    borderRadius: 10,
    borderWidth: 1,
    marginBottom: 16,
  },
  sectionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  sectionLabel: {
    fontSize: 17,
    fontWeight: '500',
  },
  sectionTitle: {
    fontSize: 17,
    fontWeight: '600',
    marginBottom: 12,
  },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    gap: 12,
  },
  thresholdSection: {
    marginBottom: 16,
  },
  thresholdLabel: {
    fontSize: 15,
    fontWeight: '600',
    marginBottom: 8,
  },
  thresholdControl: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    marginBottom: 8,
  },
  adjustButton: {
    width: 60,
    height: 60,
    borderRadius: 12,
    borderWidth: 2,
    alignItems: 'center',
    justifyContent: 'center',
  },
  adjustButtonText: {
    fontSize: 32,
    fontWeight: '700',
  },
  thresholdInput: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  input: {
    flex: 1,
    height: 60,
    borderWidth: 2,
    borderRadius: 12,
    paddingHorizontal: 16,
    fontSize: 20,
    fontWeight: '600',
    textAlign: 'center',
  },
  unit: {
    fontSize: 17,
    fontWeight: '500',
  },
  hint: {
    fontSize: 13,
    marginTop: 0,
  },
  patternDescription: {
    fontSize: 15,
    lineHeight: 22,
    marginBottom: 12,
  },
  patternOptions: {
    gap: 12,
  },
  patternOption: {
    borderRadius: 12,
    padding: 16,
    marginBottom: 0,
    minHeight: 72,
  },
  patternOptionContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 16,
  },
  patternRadio: {
    width: 24,
    height: 24,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#94A3B8',
    alignItems: 'center',
    justifyContent: 'center',
  },
  patternRadioSelected: {
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  patternText: {
    flex: 1,
  },
  patternLabel: {
    fontSize: 15,
    fontWeight: '600',
    marginBottom: 2,
  },
  patternDesc: {
    fontSize: 13,
    lineHeight: 18,
  },
  testButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 18,
    borderRadius: 12,
    minHeight: 60,
    borderWidth: 2,
    gap: 8,
  },
  testButtonText: {
    fontSize: 18,
    fontWeight: '700',
  },
  confirmDialogOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
  },
  confirmDialog: {
    width: '85%',
    maxWidth: 400,
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },
  confirmDialogTitle: {
    fontSize: 20,
    fontWeight: '700',
    marginBottom: 12,
    textAlign: 'center',
  },
  confirmDialogMessage: {
    fontSize: 16,
    lineHeight: 24,
    marginBottom: 24,
    textAlign: 'center',
  },
  confirmDialogButtons: {
    flexDirection: 'row',
    gap: 12,
  },
  confirmDialogButton: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
  },
  confirmDialogButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
});
