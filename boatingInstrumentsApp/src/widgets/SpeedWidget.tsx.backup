import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { useNmeaStore } from '../store/nmeaStore';
import { useTheme } from '../store/themeStore';
import { useWidgetStore } from '../stores/widgetStore';
import PrimaryMetricCell from '../components/PrimaryMetricCell';
import SecondaryMetricCell from '../components/SecondaryMetricCell';

interface SpeedWidgetProps {
  id: string;
  title: string;
}

/**
 * Speed Widget - STW/SOG Focus per ui-architecture.md v2.3
 * Primary Grid (1Ã—2): STW + SOG with large values
 * Secondary Grid (2Ã—2): AVG and MAX for both STW/SOG in columns
 * Interactive Chart: STW trend (tap to switch to SOG)
 */
export const SpeedWidget: React.FC<SpeedWidgetProps> = React.memo(({ id, title }) => {
  const theme = useTheme();
  
  // Widget state management per ui-architecture.md v2.3
  const { 
    isWidgetExpanded, 
    isWidgetPinned, 
    toggleWidgetExpansion, 
    toggleWidgetPin,
    updateWidgetInteraction 
  } = useWidgetStore((state) => ({
    isWidgetExpanded: (id: string) => state.widgetExpanded[id] || false,
    isWidgetPinned: (id: string) => state.isWidgetPinned(id),
    toggleWidgetExpansion: state.toggleWidgetExpanded,
    toggleWidgetPin: state.toggleWidgetPin,
    updateWidgetInteraction: state.updateWidgetInteraction
  }));

  const expanded = isWidgetExpanded(id);
  const pinned = isWidgetPinned(id);
  
  // NMEA data selectors - STW/SOG focus
  const sog = useNmeaStore(useCallback((state: any) => state.nmeaData.sog, []));
  const stw = useNmeaStore(useCallback((state: any) => state.nmeaData.stw, [])); // Speed Through Water
  const cogTimestamp = useNmeaStore(useCallback((state: any) => state.nmeaData.speedTimestamp, []));
  
  // Speed history for averages and maximums
  const [speedHistory, setSpeedHistory] = useState<{
    sog: { value: number; timestamp: number }[];
    stw: { value: number; timestamp: number }[];
  }>({ sog: [], stw: [] });

  // Track speed history for calculations
  useEffect(() => {
    const now = Date.now();
    const tenMinutesAgo = now - 10 * 60 * 1000;
    
    if (sog !== undefined && sog !== null) {
      setSpeedHistory(prev => ({
        ...prev,
        sog: [...prev.sog, { value: sog, timestamp: now }]
          .filter(entry => entry.timestamp > tenMinutesAgo)
          .slice(-300) // Keep max 300 entries
      }));
    }
    
    if (stw !== undefined && stw !== null) {
      setSpeedHistory(prev => ({
        ...prev,
        stw: [...prev.stw, { value: stw, timestamp: now }]
          .filter(entry => entry.timestamp > tenMinutesAgo)
          .slice(-300)
      }));
    }
  }, [sog, stw]);

  // Calculate averages and maximums for secondary view
  const calculations = useMemo(() => {
    const calculateStats = (data: { value: number; timestamp: number }[]) => {
      if (data.length === 0) return { avg: null, max: null };
      const values = data.map(d => d.value);
      return {
        avg: values.reduce((a, b) => a + b, 0) / values.length,
        max: Math.max(...values)
      };
    };

    return {
      sog: calculateStats(speedHistory.sog),
      stw: calculateStats(speedHistory.stw)
    };
  }, [speedHistory]);

  // Widget interaction handlers per ui-architecture.md v2.3
  const handlePress = useCallback(() => {
    toggleWidgetExpansion(id);
    updateWidgetInteraction(id);
  }, [id, toggleWidgetExpansion, updateWidgetInteraction]);

  const handleLongPressOnCaret = useCallback(() => {
    toggleWidgetPin(id);
    updateWidgetInteraction(id);
  }, [id, toggleWidgetPin, updateWidgetInteraction]);

  // Data staleness detection (>5s = stale)
  const isStale = cogTimestamp ? (Date.now() - cogTimestamp) > 5000 : true;

  return (
    <TouchableOpacity
      style={[styles.container, { backgroundColor: theme.surface }]}
      onPress={handlePress}
      activeOpacity={0.8}
      testID={`speed-widget-${id}`}
    >
      {/* Widget Header with Title and Controls */}
      <View style={styles.header}>
        <Text style={[styles.title, { color: theme.textSecondary }]}>
          {title.toUpperCase()}
        </Text>
        
        {/* Expansion Caret and Pin Controls */}
        <View style={styles.controls}>
          {pinned ? (
            <TouchableOpacity
              onLongPress={handleLongPressOnCaret}
              style={styles.controlButton}
              testID={`pin-button-${id}`}
            >
              <Text style={[styles.pinIcon, { color: theme.primary }]}>ðŸ“Œ</Text>
            </TouchableOpacity>
          ) : (
            <TouchableOpacity
              onPress={handlePress}
              onLongPress={handleLongPressOnCaret}
              style={styles.controlButton}
              testID={`caret-button-${id}`}
            >
              <Text style={[styles.caret, { color: theme.textSecondary }]}>
                {expanded ? 'âŒƒ' : 'âŒ„'}
              </Text>
            </TouchableOpacity>
          )}
        </View>
      </View>

      {/* PRIMARY GRID (1Ã—2): STW + SOG with large values */}
      <View style={styles.primaryGrid}>
        <PrimaryMetricCell
          mnemonic="SOG"
          value={sog}
          unit="kts"
          precision={1}
          state={isStale ? 'warning' : 'normal'}
          timestamp={cogTimestamp ? new Date(cogTimestamp) : undefined}
          testID={`sog-metric-${id}`}
        />
        <PrimaryMetricCell
          mnemonic="STW"
          value={stw}
          unit="kts"
          precision={1}
          state={isStale ? 'warning' : 'normal'}
          timestamp={cogTimestamp ? new Date(cogTimestamp) : undefined}
          testID={`stw-metric-${id}`}
        />
      </View>

      {/* SECONDARY GRID (2Ã—2): AVG and MAX for both STW/SOG */}
      {expanded && (
        <View style={styles.secondaryGrid}>
          <SecondaryMetricCell
            mnemonic="SOG AVG"
            value={calculations.sog.avg}
            unit="kts"
            precision={1}
            state="normal"
            compact={true}
            testID={`sog-avg-${id}`}
          />
          <SecondaryMetricCell
            mnemonic="SOG MAX"
            value={calculations.sog.max}
            unit="kts"
            precision={1}
            state="normal"
            compact={true}
            testID={`sog-max-${id}`}
          />
          <SecondaryMetricCell
            mnemonic="STW AVG"
            value={calculations.stw.avg}
            unit="kts"
            precision={1}
            state="normal"
            compact={true}
            testID={`stw-avg-${id}`}
          />
          <SecondaryMetricCell
            mnemonic="STW MAX"
            value={calculations.stw.max}
            unit="kts"
            precision={1}
            state="normal"
            compact={true}
            testID={`stw-max-${id}`}
          />
        </View>
      )}
    </TouchableOpacity>
  );
});

SpeedWidget.displayName = 'SpeedWidget';

const styles = StyleSheet.create({
  container: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: '#E5E7EB',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  title: {
    fontSize: 11,
    fontWeight: 'bold',
    letterSpacing: 0.5,
  },
  controls: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  controlButton: {
    padding: 4,
    minWidth: 24,
    alignItems: 'center',
  },
  caret: {
    fontSize: 14,
    fontWeight: 'bold',
  },
  pinIcon: {
    fontSize: 12,
  },
  // Primary Grid (1Ã—2): Side by side STW/SOG
  primaryGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  // Secondary Grid (2Ã—2): Four metrics in grid
  secondaryGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginTop: 12,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: '#E5E7EB',
  },
});

export default SpeedWidget;
  }, [sog, cog]);
  
  // Cached speed trend calculation
  const speedTrend = useCachedMarineCalculation(
    'speed-trend',
    () => calculateSpeedTrend(speedHistory),
    [speedHistory]
  );
  
  const { displaySpeed, displayCOG, state } = displayValues;

  // Story 4.4 AC6-10: Build comprehensive accessibility label
  const speedAccessibilityLabel = useMemo(() => {
    if (sog === undefined || sog === null) {
      return 'Speed: No data available';
    }
    
    const parts: string[] = ['Speed'];
    parts.push(`${displaySpeed} knots`);
    
    if (cog !== undefined && cog !== null) {
      parts.push(`Course over ground ${Math.round(cog)} degrees`);
    }
    
    // Add trend information
    if (speedTrend > 0.5) {
      parts.push('speed increasing');
    } else if (speedTrend < -0.5) {
      parts.push('speed decreasing');
    } else if (speedHistory.length > 1) {
      parts.push('speed steady');
    }
    
    return parts.join(', ');
  }, [sog, displaySpeed, cog, speedTrend, speedHistory]);

  const speedAccessibilityHint = useMemo(() => {
    if (state === 'no-data') {
      return 'Waiting for GPS speed data';
    }
    return 'Shows vessel speed over ground and course';
  }, [state]);
  
  return (
    <WidgetCard
      title="SPEED"
      icon="speedometer"
      state={state}
      accessibilityLabel={speedAccessibilityLabel}
      accessibilityHint={speedAccessibilityHint}
      accessibilityRole="text"
      accessibilityValue={sog !== undefined && sog !== null ? {
        text: `${displaySpeed} knots`,
        now: sog,
        min: 0,
        max: 50,
      } : undefined}
    >
      {/* PrimaryMetricCell Grid - 2x1 layout */}
      <View style={styles.metricGrid}>
        <PrimaryMetricCell
          mnemonic="SOG"
          value={displaySpeed}
          unit="kn"
          state={state === 'no-data' ? 'normal' : 'normal'}
          style={styles.metricCell}
        />
        <PrimaryMetricCell
          mnemonic="COG"
          value={cog !== undefined && cog !== null ? Math.round(cog) : '---'}
          unit="Â°"
          state={cog === undefined || cog === null ? 'normal' : 'normal'}
          style={styles.metricCell}
        />
      </View>

      {/* Extended Details (Course Indicator and Trend) */}
      {sog !== undefined && sog !== null && (
        <View 
          style={styles.detailsContainer}
          accessible={true}
          accessibilityRole="text"
          accessibilityLabel={`Speed over ground: ${displaySpeed} knots, Course over ground: ${displayCOG}`}
        >
          {cog !== undefined && cog !== null && (
            <View style={styles.cogIndicator}>
              <CourseIndicator course={cog} theme={theme} />
            </View>
          )}
          {speedHistory.length > 1 && (
            <View style={styles.trendContainer}>
              <Text style={[styles.trendLabel, { color: theme.textSecondary }]}>5-Min Trend</Text>
              <SpeedTrendChart history={speedHistory} theme={theme} />
              <Text style={[styles.trendValue, { color: theme.success }]}>
                {`${speedTrend > 0 ? 'â†‘' : speedTrend < 0 ? 'â†“' : 'â†’'} ${Math.abs(speedTrend).toFixed(1)} kn`}
              </Text>
            </View>
          )}
        </View>
      )}
    </WidgetCard>
  );
});

// Calculate speed trend (change over last 5 minutes)
const calculateSpeedTrend = (history: SpeedHistory[]): number => {
  if (history.length < 2) return 0;
  
  const recent = history[history.length - 1].speed;
  const old = history[0].speed;
  return recent - old;
};

// Course indicator - simple arrow pointing in COG direction
interface CourseIndicatorProps {
  course: number;
  theme: any;
}

const CourseIndicator: React.FC<CourseIndicatorProps> = React.memo(({ course, theme }) => {
  const size = 40;
  const center = size / 2;
  const length = 15;
  
  // Memoized angle calculation
  const angleCalculations = useMemo(() => {
    // Convert course to radians
    const angle = (course - 90) * (Math.PI / 180); // -90 to make 0Â° point up
    
    const x2 = center + length * Math.cos(angle);
    const y2 = center + length * Math.sin(angle);
    
    return {
      angle,
      x2,
      y2,
      arrowX1: x2 - 5 * Math.cos(angle - 0.5),
      arrowY1: y2 - 5 * Math.sin(angle - 0.5),
      arrowX2: x2 - 5 * Math.cos(angle + 0.5),
      arrowY2: y2 - 5 * Math.sin(angle + 0.5),
    };
  }, [course, center, length]);
  
  return (
    <Svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
      <Line
        x1={center}
        y1={center}
        x2={angleCalculations.x2}
        y2={angleCalculations.y2}
        stroke={theme.primary}
        strokeWidth="3"
        strokeLinecap="round"
      />
      {/* Arrow head */}
      <Line
        x1={angleCalculations.x2}
        y1={angleCalculations.y2}
        x2={angleCalculations.arrowX1}
        y2={angleCalculations.arrowY1}
        stroke={theme.primary}
        strokeWidth="2"
        strokeLinecap="round"
      />
      <Line
        x1={angleCalculations.x2}
        y1={angleCalculations.y2}
        x2={angleCalculations.arrowX2}
        y2={angleCalculations.arrowY2}
        stroke={theme.primary}
        strokeWidth="2"
        strokeLinecap="round"
      />
    </Svg>
  );
});

// Speed trend sparkline chart
interface SpeedTrendChartProps {
  history: SpeedHistory[];
  theme: any;
}

const SpeedTrendChart: React.FC<SpeedTrendChartProps> = React.memo(({ history, theme }) => {
  const chartData = useMemo(() => {
    if (history.length < 2) return null;
    
    const width = 80;
    const height = 30;
    const padding = 2;
    
    // Find min/max for scaling
    const speeds = history.map(h => h.speed);
    const minSpeed = Math.min(...speeds);
    const maxSpeed = Math.max(...speeds);
    const range = maxSpeed - minSpeed || 1; // Avoid division by zero
    
    // Create points for polyline
    const points = history.map((entry, index) => {
      const x = padding + (index / (history.length - 1)) * (width - 2 * padding);
      const y = height - padding - ((entry.speed - minSpeed) / range) * (height - 2 * padding);
      return `${x},${y}`;
    }).join(' ');
    
    return { width, height, points };
  }, [history]);

  if (!chartData) return null;
  
  return (
    <Svg width={chartData.width} height={chartData.height} viewBox={`0 0 ${chartData.width} ${chartData.height}`}>
      <Polyline
        points={chartData.points}
        fill="none"
        stroke={theme.success}
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </Svg>
  );
});

const styles = StyleSheet.create({
  metricGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    paddingHorizontal: 4,
    paddingVertical: 8,
  },
  metricCell: {
    flex: 1,
    marginHorizontal: 4,
  },
  detailsContainer: {
    marginTop: 8,
    alignItems: 'center',
    gap: 8,
  },
  cogIndicator: {
    marginVertical: 4,
  },
  trendContainer: {
    alignItems: 'center',
    marginTop: 4,
  },
  trendLabel: {
    fontSize: 10,
    textTransform: 'uppercase',
    marginBottom: 4,
  },
  trendValue: {
    fontSize: 12,
    fontWeight: '600',
    marginTop: 4,
  },
});
