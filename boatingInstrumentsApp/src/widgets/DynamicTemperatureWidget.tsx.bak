import React, { useCallback, useMemo, useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { TrendLine } from '../components/TrendLine';
import { useNmeaStore } from '../store/nmeaStore';
import { useTheme } from '../store/themeStore';
import { useWidgetStore } from '../store/widgetStore';
import { useTemperaturePresentation } from '../presentation/useDataPresentation';
import { MetricDisplayData } from '../types/MetricDisplayData';
import PrimaryMetricCell from '../components/PrimaryMetricCell';
import SecondaryMetricCell from '../components/SecondaryMetricCell';
import { TemperatureSensorData } from '../types/SensorData';
import { UniversalIcon } from '../components/atoms/UniversalIcon';
import { WidgetMetadataRegistry } from '../registry/WidgetMetadataRegistry';
import { useResponsiveFontSize } from '../hooks/useResponsiveFontSize';
import { useResponsiveHeader } from '../hooks/useResponsiveHeader';
import { UnifiedWidgetGrid } from '../components/UnifiedWidgetGrid';

interface DynamicTemperatureWidgetProps {
  id: string;
  title: string;
  width?: number;
  height?: number;
  maxWidth?: number; // Cell width from UnifiedWidgetGrid
  cellHeight?: number; // Cell height from UnifiedWidgetGrid
}

/**
 * TemperatureWidget - Enhanced with collapsible functionality and secondary metrics
 * Primary Grid (2×1): Temperature (°C/°F) + Trend Line Graph
 * Secondary Grid (2×1): Location + Instance
 * Supports multi-instance temperature sensors (seawater, engine, cabin, exhaust, etc.)
 */
export const DynamicTemperatureWidget: React.FC<DynamicTemperatureWidgetProps> = React.memo(({ id, title, width, height, maxWidth, cellHeight }) => {
  const theme = useTheme();
  const fontSize = useResponsiveFontSize(width || 0, height || 0);

  // Extract temperature instance from widget ID (e.g., "temp-0", "temp-1")
  const instanceNumber = useMemo(() => {
    const match = id.match(/temp-(\d+)/);
    return match ? parseInt(match[1], 10) : 0;
  }, [id]);
  
  // Widget state management
  const pinned = useWidgetStore((state) => state.isWidgetPinned ? state.isWidgetPinned(id) : false);
  const toggleWidgetPin = useWidgetStore((state) => state.toggleWidgetPin);
  const updateWidgetInteraction = useWidgetStore((state) => state.updateWidgetInteraction);
  
  // Subscribe to history tracking on mount
  useEffect(() => {
    const subscribeToHistory = useNmeaStore.getState().subscribeToHistory;
    const unsubscribeFromHistory = useNmeaStore.getState().unsubscribeFromHistory;
    
    subscribeToHistory(id, 'temperature', 5 * 60 * 1000);
    
    return () => {
      unsubscribeFromHistory(id, 'temperature');
    };
  }, [id]);
  
  // NMEA data - Phase 1 Optimization: Selective field subscriptions with shallow equality
  const temperature = useNmeaStore((state) => state.nmeaData.sensors.temperature?.[instanceNumber]?.value ?? null, (a, b) => a === b);
  const location = useNmeaStore((state) => state.nmeaData.sensors.temperature?.[instanceNumber]?.location ?? 'unknown', (a, b) => a === b);
  const units = useNmeaStore((state) => state.nmeaData.sensors.temperature?.[instanceNumber]?.units ?? 'C', (a, b) => a === b);
  const sensorName = useNmeaStore((state) => state.nmeaData.sensors.temperature?.[instanceNumber]?.name ?? title, (a, b) => a === b);
  const temperatureTimestamp = useNmeaStore((state) => state.nmeaData.sensors.temperature?.[instanceNumber]?.timestamp);
  
  // Get temperature history from store (per-instance)
  // CRITICAL FIX: Memoize instanceKey to prevent useEffect loop
  const instanceKey = useMemo(() => `temp-${instanceNumber}`, [instanceNumber]);
  
  // MEMORY LEAK FIX: Use stable empty object reference to prevent constant re-renders
  const emptyHistory = useMemo(() => ({ 
    values: [] as Array<{value: number; timestamp: number}>,
    timeWindow: 5 * 60 * 1000,
    maxEntries: 600
  }), []);
  
  const temperatureHistory = useNmeaStore((state) => {
    const tempHistories = state.sensorHistories.temperature as Record<string, any>;
    return tempHistories[instanceKey] || emptyHistory;
  });
  
  // Check if data is stale (> 5 seconds old)
  // Use state + useEffect to detect staleness without causing re-renders on every cycle
  const [isStale, setIsStale] = useState(true);
  
  useEffect(() => {
    if (!temperatureTimestamp) {
      setIsStale(true);
      return;
    }
    
    const checkStale = () => {
      const age = Date.now() - temperatureTimestamp;
      setIsStale(age > 5000);
    };
    
    // Check immediately when timestamp changes
    checkStale();
    
    // Then check periodically every second
    const interval = setInterval(checkStale, 1000);
    return () => clearInterval(interval);
  }, [temperatureTimestamp]); // CRITICAL: Only timestamp, not full object!
  
  // Presentation hooks for temperature conversion
  const tempPresentation = useTemperaturePresentation();
  
  // Convert temperature using presentation system
  const displayTemperature = useMemo(() => {
    if (temperature === null) return null;
    return tempPresentation.convert(temperature);
  }, [temperature, tempPresentation]);
  
  const displayUnit = tempPresentation.presentation?.symbol || '°C';

  // Marine safety thresholds for temperature monitoring
  const getTemperatureState = useCallback((temp: number | null, location: string) => {
    if (temp === null) return 'warning';
    
    // Critical conditions for marine temperature sensors
    switch (location) {
      case 'engine':
        if (temp > 95) return 'alarm';     // Dangerous engine temperature
        if (temp > 85) return 'warning';   // High engine temperature
        break;
      case 'exhaust':
        if (temp > 65) return 'alarm';     // Dangerous exhaust temperature
        if (temp > 55) return 'warning';   // High exhaust temperature
        break;
      case 'engineRoom':
        if (temp > 50) return 'alarm';     // Dangerous engine room temperature
        if (temp > 40) return 'warning';   // High engine room temperature
        break;
      case 'seawater':
        if (temp > 30 || temp < 0) return 'warning'; // Unusual seawater temperature
        break;
      case 'cabin':
      case 'outside':
        if (temp > 40 || temp < -10) return 'warning'; // Extreme air temperature
        break;
    }
    
    return 'normal';
  }, []);

  const temperatureState = getTemperatureState(temperature, location);
  
  // Wrapper component to receive injected props from UnifiedWidgetGrid
  const TrendLineCell = useCallback(({ maxWidth: cellMaxWidth, cellHeight: cellHeightValue }: { maxWidth?: number; cellHeight?: number }) => {
    const filteredData = temperatureHistory.values.filter(d => d.timestamp > Date.now() - 5 * 60 * 1000);
    return (
      <TrendLine 
        data={filteredData}
      width={cellMaxWidth || 300}
      height={cellHeightValue || 60}
      color={temperatureState === 'alarm' ? theme.error : temperatureState === 'warning' ? theme.warning : theme.primary}
      theme={theme}
      showXAxis={true}
      showYAxis={true}
      xAxisPosition="bottom"
      yAxisDirection="up"
      timeWindowMinutes={5}
      showTimeLabels={true}
      showGrid={true}
      strokeWidth={2}
    />
  );
  }, [temperatureHistory, temperatureState, theme]);

  // Widget interaction handlers
  const handlePress = useCallback(() => {
    updateWidgetInteraction(id);
  }, [id, updateWidgetInteraction]);

  const handleLongPressOnPin = useCallback(() => {
    toggleWidgetPin(id);
    updateWidgetInteraction(id);
  }, [id, toggleWidgetPin, updateWidgetInteraction]);

  // Auto-generate appropriate title based on temperature data
  const getDisplayTitle = useCallback(() => {
    // Standard NMEA temperature location mapping
    const locationMap: Record<string, string> = {
      'engine': 'Engine Room',
      'seawater': 'Sea Water',
      'outside': 'Outside Air',
      'cabin': 'Main Cabin',
      'exhaust': 'Exhaust',
      'refrigerator': 'Refrigerator',
      'freezer': 'Freezer',
      'battery': 'Battery Bay',
      'engineRoom': 'Engine Room',
    };
    
    const locationName = locationMap[location] || (location && location.length > 0 ? location.charAt(0).toUpperCase() + location.slice(1) : 'Unknown');
    
    // Format: "Temperature - [Location]" e.g. "Temperature - Engine Room", "Temperature - Sea Water"
    return `Temperature - ${locationName}`;
  }, [location]);

  // Calculate responsive header sizes based on widget dimensions
  // Responsive header sizing using proper base-size scaling
  const { iconSize: headerIconSize, fontSize: headerFontSize } = useResponsiveHeader(height);

  // Header component for UnifiedWidgetGrid v2
  const headerComponent = (
    <View style={{
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      width: '100%',
      paddingHorizontal: 16,
    }}>
      <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
        <UniversalIcon 
          name={WidgetMetadataRegistry.getMetadata('temperature')?.icon || 'thermometer-outline'} 
          size={headerIconSize} 
          color={theme.primary}
        />
        <Text style={{
          fontSize: headerFontSize,
          fontWeight: 'bold',
          letterSpacing: 0.5,
          color: theme.textSecondary,
          textTransform: 'uppercase',
        }}>{getDisplayTitle()}</Text>
      </View>
      
      {pinned && (
        <TouchableOpacity
          onLongPress={handleLongPressOnPin}
          style={{ padding: 4, minWidth: 24, alignItems: 'center' }}
          testID={`pin-button-${id}`}
        >
          <UniversalIcon name="pin" size={headerIconSize} color={theme.primary} />
        </TouchableOpacity>
      )}
    </View>
  );

  return (
    <UnifiedWidgetGrid 
      theme={theme}
      header={headerComponent}
      widgetWidth={width || 400}
      widgetHeight={height || 300}
      columns={1}
      primaryRows={2}
      secondaryRows={2}
      onPress={handlePress}
      testID={`temperature-widget-${instanceNumber}`}
    >
      {/* Primary Row 1: Temperature */}
      <PrimaryMetricCell
        mnemonic="TEMP"
        value={displayTemperature !== null ? displayTemperature.toFixed(1) : '---'}
        unit={displayUnit}
        state={isStale ? 'warning' : temperatureState}
        fontSize={{
          mnemonic: fontSize.label,
          value: fontSize.value,
          unit: fontSize.unit,
        }}
      />
      {/* Primary Row 2: Trend Line */}
      <TrendLineCell />
      
      {/* Secondary Row 1: Location */}
      <SecondaryMetricCell
        mnemonic="LOC"
        value={location && location.trim().length > 0 ? location.toUpperCase() : 'UNKNOWN'}
        unit=""
        state="normal"
        compact={true}
        fontSize={{
          mnemonic: fontSize.label,
          value: fontSize.value,
          unit: fontSize.unit,
        }}
      />
      {/* Secondary Row 2: Instance */}
      <SecondaryMetricCell
        mnemonic="INST"
        value={typeof instanceNumber === 'number' ? String(instanceNumber) : '0'}
        unit=""
        state="normal"
        compact={true}
        fontSize={{
          mnemonic: fontSize.label,
          value: fontSize.value,
          unit: fontSize.unit,
        }}
      />
    </UnifiedWidgetGrid>
  );
});

