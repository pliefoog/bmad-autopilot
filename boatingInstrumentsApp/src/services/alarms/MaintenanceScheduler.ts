/**
 * MaintenanceScheduler - Integrates maintenance tracking with smart alarm management
 * Provides engine hours tracking, usage-based maintenance reminders, and predictive maintenance
 */

import { Alarm, AlarmLevel } from '../../stores/alarmStore';
import { VesselContext } from './PriorityQueueManager';
import { NmeaDataSnapshot } from './VesselContextDetector';
import AsyncStorage from '@react-native-async-storage/async-storage';

/**
 * Maintenance schedule item
 */
export interface MaintenanceItem {
  id: string;
  name: string;
  description: string;
  category: 'engine' | 'electrical' | 'navigation' | 'safety' | 'hull' | 'systems';
  
  // Schedule configuration
  scheduleType: 'hours' | 'calendar' | 'cycles' | 'conditions';
  
  // Schedule parameters
  intervalHours?: number; // Engine/operating hours
  intervalDays?: number; // Calendar days
  intervalCycles?: number; // Usage cycles (start/stop, anchor/sail, etc.)
  
  // Condition-based maintenance
  conditionTriggers?: {
    temperatureExceeded?: number; // Count of overheating events
    lowOilPressure?: number; // Count of low pressure events
    highRpm?: number; // Count of high RPM events
    roughWeatherOperations?: number; // Hours in rough weather
    depthAlarms?: number; // Count of shallow water events
  };
  
  // Current status
  lastPerformed?: number; // Timestamp
  currentHours: number; // Hours accumulated since last maintenance
  currentDays: number; // Days since last maintenance
  currentCycles: number; // Cycles since last maintenance
  currentConditions: MaintenanceItem['conditionTriggers']; // Current condition counts
  
  // Thresholds and warnings
  warningThreshold: number; // % of interval to show warning (0.8 = 80%)
  criticalThreshold: number; // % of interval to show critical (0.95 = 95%)
  overdueThreshold: number; // % over interval to show overdue (1.1 = 110%)
  
  // Priority and impact
  priority: 'low' | 'medium' | 'high' | 'critical';
  safetyImpact: boolean; // If true, affects vessel safety
  
  // Metadata
  estimatedTime: number; // Minutes to complete
  cost?: number; // Estimated cost
  parts?: string[]; // Required parts
  tools?: string[]; // Required tools
  expertise?: 'basic' | 'intermediate' | 'professional'; // Required expertise
  
  // Learning and optimization
  actualCompletionTimes: number[]; // Historical completion times
  lastAlarmGenerated?: number; // When we last generated an alarm
  userPostponements: number; // How many times user postponed
  
  // Integration
  linkedAlarms?: string[]; // Alarm types that relate to this maintenance
  createdAt: number;
  updatedAt: number;
}

/**
 * Maintenance alarm generated by scheduler
 */
export interface MaintenanceAlarm extends Omit<Alarm, 'id' | 'timestamp'> {
  maintenanceId: string;
  maintenanceType: 'preventive' | 'predictive' | 'overdue' | 'condition_based';
  
  // Progress information
  completion: number; // 0-1 representing how close to due
  timeRemaining?: string; // Human readable time remaining
  
  // Actions available
  availableActions: ('postpone' | 'mark_complete' | 'schedule' | 'ignore')[];
  postponeOptions?: { hours: number; reason: string }[]; // Available postpone options
  
  // Cost and impact
  estimatedCost?: number;
  safetyRisk: 'none' | 'low' | 'medium' | 'high';
  
  // Context
  recommendedConditions?: VesselContext['state'][]; // Best conditions to perform maintenance
}

/**
 * Engine usage tracking
 */
export interface EngineUsage {
  totalHours: number;
  hoursThisMonth: number;
  hoursThisYear: number;
  
  // Usage patterns
  averageRpm: number;
  maxRpm: number;
  thermalCycles: number; // Heat up/cool down cycles
  
  // Conditions
  roughWeatherHours: number;
  highLoadHours: number; // Hours at high RPM
  idleHours: number;
  
  // Tracking
  lastUpdated: number;
  sessionStartTime?: number;
  sessionHours: number;
}

/**
 * Predictive maintenance configuration
 */
export interface PredictiveConfig {
  enabled: boolean;
  
  // Learning parameters
  learningPeriodDays: number; // Days to collect baseline data
  predictionHorizonDays: number; // How far ahead to predict
  confidenceThreshold: number; // Minimum confidence for predictions
  
  // Condition monitoring
  temperatureAnalysis: boolean;
  pressureAnalysis: boolean;
  vibrationAnalysis: boolean; // If vibration sensors available
  performanceAnalysis: boolean; // RPM, fuel consumption patterns
  
  // Alarm integration
  suppressDuplicateAlarms: boolean; // Don't alarm if recent maintenance alarm exists
  contextAwareness: boolean; // Consider vessel context for maintenance timing
  weatherIntegration: boolean; // Delay maintenance suggestions in bad weather
  
  // Notifications
  advanceNotificationDays: number; // Days ahead to start notifications
  escalationEnabled: boolean; // Escalate overdue maintenance
  
  // User preferences
  preferredMaintenanceDays: ('monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday')[];
  maintenanceWindowHours: { start: number; end: number }; // Preferred hours (0-23)
}

/**
 * Maintenance scheduler for smart alarm integration
 */
export class MaintenanceScheduler {
  private config: PredictiveConfig;
  private maintenanceItems: MaintenanceItem[] = [];
  private engineUsage: EngineUsage;
  private activeAlarms: MaintenanceAlarm[] = [];
  
  private readonly storageKey = 'maintenance-scheduler';
  private saveScheduled = false;
  
  // Usage tracking
  private usageTimer?: NodeJS.Timeout;
  private lastNmeaUpdate: number = 0;
  
  // Maintenance checking
  private maintenanceCheckTimer?: NodeJS.Timeout;
  
  constructor(config?: Partial<PredictiveConfig>) {
    this.config = {
      enabled: true,
      learningPeriodDays: 30,
      predictionHorizonDays: 14,
      confidenceThreshold: 0.7,
      
      temperatureAnalysis: true,
      pressureAnalysis: true,
      vibrationAnalysis: false,
      performanceAnalysis: true,
      
      suppressDuplicateAlarms: true,
      contextAwareness: true,
      weatherIntegration: true,
      
      advanceNotificationDays: 7,
      escalationEnabled: true,
      
      preferredMaintenanceDays: ['saturday', 'sunday'],
      maintenanceWindowHours: { start: 9, end: 17 }, // 9 AM to 5 PM
      
      ...config,
    };
    
    this.engineUsage = {
      totalHours: 0,
      hoursThisMonth: 0,
      hoursThisYear: 0,
      averageRpm: 0,
      maxRpm: 0,
      thermalCycles: 0,
      roughWeatherHours: 0,
      highLoadHours: 0,
      idleHours: 0,
      lastUpdated: Date.now(),
      sessionHours: 0,
    };
    
    this.loadFromStorage();
    this.startUsageTracking();
    this.startMaintenanceChecking();
  }
  
  /**
   * Update engine usage with NMEA data
   */
  public updateEngineUsage(
    nmeaData: Partial<NmeaDataSnapshot>,
    context: VesselContext
  ): void {
    if (!this.config.enabled) return;
    
    const now = Date.now();
    const timeDelta = (now - this.lastNmeaUpdate) / (1000 * 60 * 60); // Hours
    
    if (timeDelta < 0.01) return; // Minimum 36 second intervals
    
    this.lastNmeaUpdate = now;
    
    // Check if engine is running (based on RPM or speed)
    const engineRunning = this.isEngineRunning(nmeaData, context);
    
    if (engineRunning) {
      // Update basic usage
      this.engineUsage.totalHours += timeDelta;
      this.engineUsage.hoursThisMonth += timeDelta;
      this.engineUsage.hoursThisYear += timeDelta;
      this.engineUsage.sessionHours += timeDelta;
      
      // Update RPM statistics
      if (nmeaData.engineRpm && nmeaData.engineRpm > 0) {
        this.engineUsage.averageRpm = (this.engineUsage.averageRpm + nmeaData.engineRpm) / 2;
        this.engineUsage.maxRpm = Math.max(this.engineUsage.maxRpm, nmeaData.engineRpm);
        
        // Track high load hours
        if (nmeaData.engineRpm > 3000) { // Configurable threshold
          this.engineUsage.highLoadHours += timeDelta;
        }
        
        // Track idle hours
        if (nmeaData.engineRpm < 1000) {
          this.engineUsage.idleHours += timeDelta;
        }
      }
      
      // Track rough weather operations
      if (context.weather === 'rough' || context.weather === 'severe') {
        this.engineUsage.roughWeatherHours += timeDelta;
      }
      
      // Update maintenance item hours
      for (const item of this.maintenanceItems) {
        if (item.scheduleType === 'hours') {
          item.currentHours += timeDelta;
        }
      }
    }
    
    // Track thermal cycles (engine start/stop)
    if (this.detectThermalCycle(nmeaData)) {
      this.engineUsage.thermalCycles++;
      
      // Update cycle-based maintenance
      for (const item of this.maintenanceItems) {
        if (item.scheduleType === 'cycles') {
          item.currentCycles++;
        }
      }
    }
    
    this.engineUsage.lastUpdated = now;
    this.scheduleSave();
  }
  
  /**
   * Update condition-based maintenance counters
   */
  public updateMaintenanceConditions(alarm: Alarm): void {
    if (!this.config.enabled) return;
    
    const conditionType = this.classifyAlarmCondition(alarm);
    
    if (!conditionType) return;
    
    // Update condition counts for relevant maintenance items
    for (const item of this.maintenanceItems) {
      if (item.scheduleType === 'conditions' && item.conditionTriggers) {
        if (!item.currentConditions) {
          item.currentConditions = {};
        }
        
        const currentCount = item.currentConditions[conditionType] || 0;
        (item.currentConditions as any)[conditionType] = currentCount + 1;
        
        item.updatedAt = Date.now();
      }
    }
    
    this.scheduleSave();
  }
  
  /**
   * Check for due maintenance and generate alarms
   */
  public checkMaintenanceAlarms(context: VesselContext): MaintenanceAlarm[] {
    if (!this.config.enabled) {
      return [];
    }
    
    const now = Date.now();
    const newAlarms: MaintenanceAlarm[] = [];
    
    for (const item of this.maintenanceItems) {
      const status = this.calculateMaintenanceStatus(item, now);
      
      if (status.isDue || status.isOverdue || status.isWarning) {
        // Check if we should suppress duplicate alarms
        if (this.shouldSuppressAlarm(item, now)) {
          continue;
        }
        
        // Check context awareness
        if (this.config.contextAwareness && !this.isSuitableMaintenanceContext(item, context)) {
          continue;
        }
        
        const alarm = this.createMaintenanceAlarm(item, status, context);
        newAlarms.push(alarm);
        
        // Update last alarm time
        item.lastAlarmGenerated = now;
      }
    }
    
    // Update active alarms
    this.activeAlarms = [...this.activeAlarms.filter(alarm => 
      !newAlarms.some(newAlarm => newAlarm.maintenanceId === alarm.maintenanceId)
    ), ...newAlarms];
    
    return newAlarms;
  }
  
  /**
   * Mark maintenance as completed
   */
  public completeMaintenance(
    maintenanceId: string,
    actualTime?: number,
    notes?: string
  ): { success: boolean; message: string } {
    const item = this.maintenanceItems.find(m => m.id === maintenanceId);
    
    if (!item) {
      return { success: false, message: 'Maintenance item not found' };
    }
    
    const now = Date.now();
    
    // Reset counters
    item.lastPerformed = now;
    item.currentHours = 0;
    item.currentDays = 0;
    item.currentCycles = 0;
    item.currentConditions = {};
    item.updatedAt = now;
    
    // Track actual completion time
    if (actualTime) {
      item.actualCompletionTimes.push(actualTime);
      
      // Keep only last 10 completion times
      if (item.actualCompletionTimes.length > 10) {
        item.actualCompletionTimes = item.actualCompletionTimes.slice(-10);
      }
    }
    
    // Remove active alarms for this maintenance
    this.activeAlarms = this.activeAlarms.filter(alarm => 
      alarm.maintenanceId !== maintenanceId
    );
    
    this.scheduleSave();
    
    console.log(`MaintenanceScheduler: Completed maintenance ${item.name}`, {
      maintenanceId,
      actualTime,
      notes,
    });
    
    return { 
      success: true, 
      message: `${item.name} marked as completed` 
    };
  }
  
  /**
   * Postpone maintenance
   */
  public postponeMaintenance(
    maintenanceId: string,
    postponeHours: number,
    reason: string
  ): { success: boolean; message: string } {
    const item = this.maintenanceItems.find(m => m.id === maintenanceId);
    
    if (!item) {
      return { success: false, message: 'Maintenance item not found' };
    }
    
    // Track postponement
    item.userPostponements++;
    
    // Adjust thresholds to delay alarm
    const postponeRatio = postponeHours / (item.intervalHours || 1);
    item.warningThreshold += postponeRatio;
    item.criticalThreshold += postponeRatio;
    
    // Remove current alarm
    this.activeAlarms = this.activeAlarms.filter(alarm => 
      alarm.maintenanceId !== maintenanceId
    );
    
    item.updatedAt = Date.now();
    this.scheduleSave();
    
    console.log(`MaintenanceScheduler: Postponed maintenance ${item.name}`, {
      maintenanceId,
      postponeHours,
      reason,
      postponements: item.userPostponements,
    });
    
    return { 
      success: true, 
      message: `${item.name} postponed for ${postponeHours} hours` 
    };
  }
  
  /**
   * Add custom maintenance item
   */
  public addMaintenanceItem(item: Omit<MaintenanceItem, 'id' | 'createdAt' | 'updatedAt'>): MaintenanceItem {
    const now = Date.now();
    
    const newItem: MaintenanceItem = {
      ...item,
      id: `maintenance-${now}-${Math.random().toString(36).substr(2, 9)}`,
      currentConditions: item.currentConditions || {},
      actualCompletionTimes: [],
      userPostponements: 0,
      createdAt: now,
      updatedAt: now,
    };
    
    this.maintenanceItems.push(newItem);
    this.scheduleSave();
    
    return newItem;
  }
  
  /**
   * Get maintenance statistics
   */
  public getMaintenanceStats(): {
    totalItems: number;
    overdueItems: number;
    warningItems: number;
    completedThisMonth: number;
    totalEngineHours: number;
    averageCompletionTime: number;
    postponementRate: number;
  } {
    const now = Date.now();
    const monthAgo = now - (30 * 24 * 60 * 60 * 1000);
    
    let overdueCount = 0;
    let warningCount = 0;
    let completedThisMonth = 0;
    let totalCompletionTimes: number[] = [];
    let totalPostponements = 0;
    
    for (const item of this.maintenanceItems) {
      const status = this.calculateMaintenanceStatus(item, now);
      
      if (status.isOverdue) overdueCount++;
      else if (status.isWarning) warningCount++;
      
      if (item.lastPerformed && item.lastPerformed >= monthAgo) {
        completedThisMonth++;
      }
      
      totalCompletionTimes = [...totalCompletionTimes, ...item.actualCompletionTimes];
      totalPostponements += item.userPostponements;
    }
    
    const averageCompletionTime = totalCompletionTimes.length > 0
      ? totalCompletionTimes.reduce((sum, time) => sum + time, 0) / totalCompletionTimes.length
      : 0;
    
    const postponementRate = this.maintenanceItems.length > 0
      ? totalPostponements / this.maintenanceItems.length
      : 0;
    
    return {
      totalItems: this.maintenanceItems.length,
      overdueItems: overdueCount,
      warningItems: warningCount,
      completedThisMonth,
      totalEngineHours: this.engineUsage.totalHours,
      averageCompletionTime,
      postponementRate,
    };
  }
  
  /**
   * Get predictive maintenance recommendations
   */
  public getPredictiveRecommendations(context: VesselContext): {
    recommendations: MaintenanceItem[];
    confidence: number;
    reasoning: string;
  }[] {
    if (!this.config.enabled) return [];
    
    const recommendations: { recommendations: MaintenanceItem[]; confidence: number; reasoning: string; }[] = [];
    
    // Analyze usage patterns
    const usageAnalysis = this.analyzeUsagePatterns();
    
    // Temperature-based predictions
    if (this.config.temperatureAnalysis) {
      const tempRecommendations = this.analyzeTempuraturePatterns(usageAnalysis);
      recommendations.push(...tempRecommendations);
    }
    
    // Performance-based predictions
    if (this.config.performanceAnalysis) {
      const perfRecommendations = this.analyzePerformancePatterns(usageAnalysis);
      recommendations.push(...perfRecommendations);
    }
    
    // Filter by confidence threshold
    return recommendations.filter(rec => rec.confidence >= this.config.confidenceThreshold);
  }
  
  /**
   * Export maintenance data
   */
  public exportMaintenanceData(): {
    maintenanceItems: MaintenanceItem[];
    engineUsage: EngineUsage;
    stats: ReturnType<MaintenanceScheduler['getMaintenanceStats']>;
    exportDate: string;
  } {
    return {
      maintenanceItems: [...this.maintenanceItems],
      engineUsage: { ...this.engineUsage },
      stats: this.getMaintenanceStats(),
      exportDate: new Date().toISOString(),
    };
  }
  
  // Private implementation methods
  
  private isEngineRunning(nmeaData: Partial<NmeaDataSnapshot>, context: VesselContext): boolean {
    // Engine running indicators
    if (nmeaData.engineRpm && nmeaData.engineRpm > 500) {
      return true;
    }
    
    // Speed-based detection (if no RPM data)
    if (nmeaData.speed && nmeaData.speed > 2 && context.state === 'motoring') {
      return true;
    }
    
    // Temperature-based detection (engine warm)
    if (nmeaData.engineTemp && nmeaData.engineTemp > 60) {
      return true;
    }
    
    return false;
  }
  
  private detectThermalCycle(nmeaData: Partial<NmeaDataSnapshot>): boolean {
    // Simple thermal cycle detection - engine temperature crossing thresholds
    // This would be enhanced with better state tracking in a real implementation
    
    if (!nmeaData.engineTemp) return false;
    
    const temp = nmeaData.engineTemp;
    
    // Detect significant temperature changes (simplified)
    const coolThreshold = 40; // Below this is "cold"
    const warmThreshold = 70; // Above this is "warm"
    
    // This would need proper state tracking to detect transitions
    // For now, just detect when engine reaches operating temperature
    return temp >= warmThreshold;
  }
  
  private classifyAlarmCondition(alarm: Alarm): keyof NonNullable<MaintenanceItem['conditionTriggers']> | null {
    const message = alarm.message.toLowerCase();
    const source = (alarm.source || '').toLowerCase();
    
    if (message.includes('temperature') || message.includes('overheat') || source.includes('temp')) {
      return 'temperatureExceeded';
    }
    
    if (message.includes('oil pressure') || message.includes('pressure') || source.includes('oil')) {
      return 'lowOilPressure';
    }
    
    if (message.includes('rpm') || message.includes('engine speed') || source.includes('rpm')) {
      return 'highRpm';
    }
    
    if (message.includes('depth') || message.includes('shallow') || source.includes('depth')) {
      return 'depthAlarms';
    }
    
    // Weather-related could indicate rough conditions
    if (message.includes('wind') || message.includes('wave') || source.includes('weather')) {
      return 'roughWeatherOperations';
    }
    
    return null;
  }
  
  private calculateMaintenanceStatus(item: MaintenanceItem, now: number): {
    isDue: boolean;
    isOverdue: boolean;
    isWarning: boolean;
    completion: number;
    timeRemaining?: string;
  } {
    let completion = 0;
    let timeRemaining: string | undefined;
    
    // Calculate completion based on schedule type
    switch (item.scheduleType) {
      case 'hours':
        if (item.intervalHours) {
          completion = item.currentHours / item.intervalHours;
          const hoursLeft = item.intervalHours - item.currentHours;
          timeRemaining = hoursLeft > 0 ? `${Math.ceil(hoursLeft)} hours` : 'Overdue';
        }
        break;
        
      case 'calendar':
        if (item.intervalDays && item.lastPerformed) {
          const daysSinceLastPerformed = (now - item.lastPerformed) / (24 * 60 * 60 * 1000);
          completion = daysSinceLastPerformed / item.intervalDays;
          const daysLeft = item.intervalDays - daysSinceLastPerformed;
          timeRemaining = daysLeft > 0 ? `${Math.ceil(daysLeft)} days` : 'Overdue';
        }
        break;
        
      case 'cycles':
        if (item.intervalCycles) {
          completion = item.currentCycles / item.intervalCycles;
          const cyclesLeft = item.intervalCycles - item.currentCycles;
          timeRemaining = cyclesLeft > 0 ? `${cyclesLeft} cycles` : 'Overdue';
        }
        break;
        
      case 'conditions':
        if (item.conditionTriggers && item.currentConditions) {
          let maxConditionCompletion = 0;
          
          for (const [condition, threshold] of Object.entries(item.conditionTriggers)) {
            const currentCount = item.currentConditions[condition as keyof typeof item.conditionTriggers] || 0;
            const conditionCompletion = currentCount / (threshold || 1);
            maxConditionCompletion = Math.max(maxConditionCompletion, conditionCompletion);
          }
          
          completion = maxConditionCompletion;
          timeRemaining = completion >= 1 ? 'Conditions met' : 'Monitor conditions';
        }
        break;
    }
    
    const isWarning = completion >= item.warningThreshold && completion < item.criticalThreshold;
    const isDue = completion >= item.criticalThreshold && completion < item.overdueThreshold;
    const isOverdue = completion >= item.overdueThreshold;
    
    return {
      isDue,
      isOverdue,
      isWarning,
      completion: Math.min(completion, 1.5), // Cap at 150% for display
      timeRemaining,
    };
  }
  
  private shouldSuppressAlarm(item: MaintenanceItem, now: number): boolean {
    if (!this.config.suppressDuplicateAlarms) return false;
    
    // Suppress if alarm was generated recently (within last hour)
    if (item.lastAlarmGenerated && (now - item.lastAlarmGenerated) < 60 * 60 * 1000) {
      return true;
    }
    
    return false;
  }
  
  private isSuitableMaintenanceContext(item: MaintenanceItem, context: VesselContext): boolean {
    // Don't suggest maintenance in bad weather
    if (this.config.weatherIntegration && (context.weather === 'severe' || context.weather === 'rough')) {
      return false;
    }
    
    // Don't suggest maintenance while actively navigating
    if (context.state === 'sailing' || context.state === 'motoring') {
      return false;
    }
    
    // Prefer maintenance when anchored
    if (context.state === 'anchored') {
      return true;
    }
    
    return true;
  }
  
  private createMaintenanceAlarm(
    item: MaintenanceItem,
    status: ReturnType<MaintenanceScheduler['calculateMaintenanceStatus']>,
    context: VesselContext
  ): MaintenanceAlarm {
    let level: AlarmLevel = 'info';
    let maintenanceType: MaintenanceAlarm['maintenanceType'] = 'preventive';
    
    if (status.isOverdue) {
      level = item.safetyImpact ? 'critical' : 'warning';
      maintenanceType = 'overdue';
    } else if (status.isDue) {
      level = item.priority === 'critical' ? 'warning' : 'info';
      maintenanceType = 'preventive';
    } else if (status.isWarning) {
      level = 'info';
      maintenanceType = 'preventive';
    }
    
    // Determine available actions
    const availableActions: MaintenanceAlarm['availableActions'] = ['mark_complete', 'postpone'];
    
    if (!status.isOverdue) {
      availableActions.push('ignore');
    }
    
    // Postpone options
    const postponeOptions = [
      { hours: 24, reason: 'Weather conditions' },
      { hours: 72, reason: 'Parts on order' },
      { hours: 168, reason: 'Schedule conflict' },
    ];
    
    return {
      maintenanceId: item.id,
      maintenanceType,
      level,
      message: this.createMaintenanceMessage(item, status),
      source: 'maintenance_scheduler',
      value: status.completion,
      threshold: 1.0,
      
      completion: status.completion,
      timeRemaining: status.timeRemaining,
      
      availableActions,
      postponeOptions,
      
      estimatedCost: item.cost,
      safetyRisk: item.safetyImpact ? (status.isOverdue ? 'high' : 'medium') : 'low',
      
      recommendedConditions: ['anchored'],
    };
  }
  
  private createMaintenanceMessage(
    item: MaintenanceItem,
    status: ReturnType<MaintenanceScheduler['calculateMaintenanceStatus']>
  ): string {
    const completionPercent = Math.round(status.completion * 100);
    
    if (status.isOverdue) {
      return `OVERDUE: ${item.name} (${completionPercent}% of interval)`;
    } else if (status.isDue) {
      return `DUE: ${item.name} (${completionPercent}% of interval)`;
    } else if (status.isWarning) {
      return `APPROACHING: ${item.name} (${completionPercent}% of interval)`;
    }
    
    return `${item.name} maintenance required`;
  }
  
  private analyzeUsagePatterns(): {
    averageHoursPerDay: number;
    peakUsageHours: number[];
    roughWeatherRatio: number;
    highLoadRatio: number;
  } {
    const daysOfData = Math.max(1, (Date.now() - (this.engineUsage.lastUpdated - 30 * 24 * 60 * 60 * 1000)) / (24 * 60 * 60 * 1000));
    
    return {
      averageHoursPerDay: this.engineUsage.totalHours / daysOfData,
      peakUsageHours: [8, 9, 10, 16, 17, 18], // Typical peak usage hours
      roughWeatherRatio: this.engineUsage.roughWeatherHours / Math.max(1, this.engineUsage.totalHours),
      highLoadRatio: this.engineUsage.highLoadHours / Math.max(1, this.engineUsage.totalHours),
    };
  }
  
  private analyzeTempuraturePatterns(usageAnalysis: ReturnType<MaintenanceScheduler['analyzeUsagePatterns']>): {
    recommendations: MaintenanceItem[];
    confidence: number;
    reasoning: string;
  }[] {
    const recommendations: { recommendations: MaintenanceItem[]; confidence: number; reasoning: string; }[] = [];
    
    // Find temperature-related maintenance items
    const tempItems = this.maintenanceItems.filter(item =>
      item.category === 'engine' &&
      (item.name.toLowerCase().includes('coolant') ||
       item.name.toLowerCase().includes('thermostat') ||
       item.name.toLowerCase().includes('temperature'))
    );
    
    // If high thermal cycles or rough weather usage, recommend cooling system maintenance
    if (usageAnalysis.roughWeatherRatio > 0.3 || this.engineUsage.thermalCycles > 100) {
      recommendations.push({
        recommendations: tempItems,
        confidence: 0.8,
        reasoning: `High thermal stress detected (${Math.round(usageAnalysis.roughWeatherRatio * 100)}% rough weather usage, ${this.engineUsage.thermalCycles} thermal cycles)`,
      });
    }
    
    return recommendations;
  }
  
  private analyzePerformancePatterns(usageAnalysis: ReturnType<MaintenanceScheduler['analyzeUsagePatterns']>): {
    recommendations: MaintenanceItem[];
    confidence: number;
    reasoning: string;
  }[] {
    const recommendations: { recommendations: MaintenanceItem[]; confidence: number; reasoning: string; }[] = [];
    
    // Find performance-related maintenance items
    const perfItems = this.maintenanceItems.filter(item =>
      item.category === 'engine' &&
      (item.name.toLowerCase().includes('filter') ||
       item.name.toLowerCase().includes('oil') ||
       item.name.toLowerCase().includes('fuel'))
    );
    
    // If high load usage, recommend more frequent oil/filter changes
    if (usageAnalysis.highLoadRatio > 0.4) {
      recommendations.push({
        recommendations: perfItems,
        confidence: 0.75,
        reasoning: `High load operation detected (${Math.round(usageAnalysis.highLoadRatio * 100)}% of running time above 3000 RPM)`,
      });
    }
    
    return recommendations;
  }
  
  private startUsageTracking(): void {
    // Update usage tracking every minute
    this.usageTimer = setInterval(() => {
      // Update calendar-based maintenance
      const now = Date.now();
      
      for (const item of this.maintenanceItems) {
        if (item.scheduleType === 'calendar' && item.lastPerformed) {
          item.currentDays = (now - item.lastPerformed) / (24 * 60 * 60 * 1000);
        }
      }
      
      // Update monthly/yearly rollover
      this.updateUsageRollover(now);
      
    }, 60 * 1000);
  }
  
  private updateUsageRollover(now: number): void {
    const currentDate = new Date(now);
    const lastUpdateDate = new Date(this.engineUsage.lastUpdated);
    
    // Reset monthly hours if month changed
    if (currentDate.getMonth() !== lastUpdateDate.getMonth() ||
        currentDate.getFullYear() !== lastUpdateDate.getFullYear()) {
      this.engineUsage.hoursThisMonth = 0;
    }
    
    // Reset yearly hours if year changed
    if (currentDate.getFullYear() !== lastUpdateDate.getFullYear()) {
      this.engineUsage.hoursThisYear = 0;
    }
  }
  
  private startMaintenanceChecking(): void {
    // Check for maintenance alarms every 10 minutes
    this.maintenanceCheckTimer = setInterval(() => {
      // This would be called by the main alarm system
      // Just update internal state here
      this.scheduleSave();
    }, 10 * 60 * 1000);
  }
  
  private scheduleSave(): void {
    if (!this.saveScheduled) {
      this.saveScheduled = true;
      
      setTimeout(() => {
        this.saveToStorage();
        this.saveScheduled = false;
      }, 5000);
    }
  }
  
  private async loadFromStorage(): Promise<void> {
    try {
      const stored = await AsyncStorage.getItem(this.storageKey);
      
      if (stored) {
        const data = JSON.parse(stored);
        
        this.maintenanceItems = data.maintenanceItems || [];
        this.engineUsage = { ...this.engineUsage, ...(data.engineUsage || {}) };
        this.activeAlarms = data.activeAlarms || [];
        
        // Load default maintenance items if none exist
        if (this.maintenanceItems.length === 0) {
          this.loadDefaultMaintenanceItems();
        }
        
        console.log('MaintenanceScheduler: Loaded from storage', {
          items: this.maintenanceItems.length,
          totalHours: this.engineUsage.totalHours,
          activeAlarms: this.activeAlarms.length,
        });
      } else {
        this.loadDefaultMaintenanceItems();
      }
    } catch (error) {
      console.error('MaintenanceScheduler: Failed to load from storage', error);
      this.loadDefaultMaintenanceItems();
    }
  }
  
  private async saveToStorage(): Promise<void> {
    try {
      const data = {
        maintenanceItems: this.maintenanceItems,
        engineUsage: this.engineUsage,
        activeAlarms: this.activeAlarms,
        lastSaved: Date.now(),
      };
      
      await AsyncStorage.setItem(this.storageKey, JSON.stringify(data));
      
    } catch (error) {
      console.error('MaintenanceScheduler: Failed to save to storage', error);
    }
  }
  
  private loadDefaultMaintenanceItems(): void {
    const defaultItems: Omit<MaintenanceItem, 'id' | 'createdAt' | 'updatedAt'>[] = [
      // Engine maintenance
      {
        name: 'Engine Oil Change',
        description: 'Change engine oil and filter',
        category: 'engine',
        scheduleType: 'hours',
        intervalHours: 100,
        currentHours: 0,
        currentDays: 0,
        currentCycles: 0,
        currentConditions: {},
        warningThreshold: 0.8,
        criticalThreshold: 0.95,
        overdueThreshold: 1.1,
        priority: 'high',
        safetyImpact: true,
        estimatedTime: 45,
        cost: 75,
        parts: ['Engine oil', 'Oil filter'],
        tools: ['Wrench set', 'Oil drain pan'],
        expertise: 'basic',
        actualCompletionTimes: [],
        userPostponements: 0,
        linkedAlarms: ['oil_pressure_low', 'engine_temperature_high'],
      },
      
      {
        name: 'Fuel Filter Replacement',
        description: 'Replace primary and secondary fuel filters',
        category: 'engine',
        scheduleType: 'hours',
        intervalHours: 200,
        currentHours: 0,
        currentDays: 0,
        currentCycles: 0,
        currentConditions: {},
        warningThreshold: 0.85,
        criticalThreshold: 0.95,
        overdueThreshold: 1.05,
        priority: 'medium',
        safetyImpact: true,
        estimatedTime: 30,
        cost: 45,
        parts: ['Primary fuel filter', 'Secondary fuel filter'],
        tools: ['Filter wrench'],
        expertise: 'basic',
        actualCompletionTimes: [],
        userPostponements: 0,
        linkedAlarms: ['fuel_pressure_low', 'engine_roughness'],
      },
      
      {
        name: 'Cooling System Inspection',
        description: 'Check coolant level, hoses, and belts',
        category: 'engine',
        scheduleType: 'calendar',
        intervalDays: 90,
        currentHours: 0,
        currentDays: 0,
        currentCycles: 0,
        currentConditions: {},
        warningThreshold: 0.8,
        criticalThreshold: 0.9,
        overdueThreshold: 1.2,
        priority: 'high',
        safetyImpact: true,
        estimatedTime: 60,
        cost: 25,
        parts: ['Coolant'],
        tools: ['Basic tools'],
        expertise: 'basic',
        actualCompletionTimes: [],
        userPostponements: 0,
        linkedAlarms: ['engine_temperature_high', 'coolant_level_low'],
      },
      
      // Safety equipment
      {
        name: 'Safety Equipment Inspection',
        description: 'Check life jackets, flares, fire extinguisher',
        category: 'safety',
        scheduleType: 'calendar',
        intervalDays: 180,
        currentHours: 0,
        currentDays: 0,
        currentCycles: 0,
        currentConditions: {},
        warningThreshold: 0.9,
        criticalThreshold: 0.95,
        overdueThreshold: 1.0,
        priority: 'critical',
        safetyImpact: true,
        estimatedTime: 30,
        cost: 0,
        parts: [],
        tools: [],
        expertise: 'basic',
        actualCompletionTimes: [],
        userPostponements: 0,
      },
      
      // Navigation equipment
      {
        name: 'GPS System Backup',
        description: 'Backup GPS waypoints and update charts',
        category: 'navigation',
        scheduleType: 'calendar',
        intervalDays: 30,
        currentHours: 0,
        currentDays: 0,
        currentCycles: 0,
        currentConditions: {},
        warningThreshold: 0.8,
        criticalThreshold: 0.9,
        overdueThreshold: 1.5,
        priority: 'medium',
        safetyImpact: false,
        estimatedTime: 15,
        cost: 0,
        parts: [],
        tools: ['Memory card'],
        expertise: 'basic',
        actualCompletionTimes: [],
        userPostponements: 0,
      },
    ];
    
    // Add default items
    for (const item of defaultItems) {
      this.addMaintenanceItem(item);
    }
    
    console.log('MaintenanceScheduler: Loaded default maintenance items', {
      count: defaultItems.length,
    });
  }
  
  public cleanup(): void {
    if (this.usageTimer) {
      clearInterval(this.usageTimer);
      this.usageTimer = undefined;
    }
    
    if (this.maintenanceCheckTimer) {
      clearInterval(this.maintenanceCheckTimer);
      this.maintenanceCheckTimer = undefined;
    }
  }
}